<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vue源码解析 transition</title>
    <link href="/2020/06/19/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-transition/"/>
    <url>/2020/06/19/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-transition/</url>
    
    <content type="html"><![CDATA[<p>　　<code>transition</code>组件是<code>Vue</code>内置组件。我们从<code>entry-runtime-with-compiler</code>这个版本的<code>JS</code>进行分析。</p><h3 id="内置组件注册"><a href="#内置组件注册" class="headerlink" title="内置组件注册"></a>内置组件注册</h3><p>　　<code>transition</code>组件是和平台相关的组件（web专属）,所以不在<code>core</code>里面。而是在相关平台<code>JS</code>里引入的。</p><pre><code class="hljs javascript"><span class="hljs-comment">// entry-runtime-with-compiler</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'./runtime/index'</span><span class="hljs-comment">// runtime/index </span><span class="hljs-keyword">import</span> platformComponents <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/index'</span>...<span class="hljs-comment">// 加载平台相关的组件和指令</span>extend(Vue.options.components, platformComponents)</code></pre><h3 id="transition-组件"><a href="#transition-组件" class="headerlink" title="transition 组件"></a>transition 组件</h3><ul><li>我们先来一个示例<code>demo</code>。<pre><code class="hljs javascript"><span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;  el: <span class="hljs-string">'#app'</span>,  template: <span class="hljs-string">'&lt;div id="demo"&gt;'</span> +  <span class="hljs-string">'&lt;button v-on:click="show = !show"&gt;'</span> +  <span class="hljs-string">'Toggle'</span> +  <span class="hljs-string">'&lt;/button&gt;'</span> +  <span class="hljs-string">'&lt;transition :appear="true" name="fade"&gt;'</span> +  <span class="hljs-string">'&lt;p v-if="show"&gt;hello&lt;/p&gt;'</span> +  <span class="hljs-string">'&lt;/transition&gt;'</span> +  <span class="hljs-string">'&lt;/div&gt;'</span>,  data() &#123;    <span class="hljs-keyword">return</span> &#123;      show: <span class="hljs-literal">true</span>    &#125;  &#125;&#125;)</code></pre></li><li>transition render<pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  name: <span class="hljs-string">'transition'</span>,  props: transitionProps,  <span class="hljs-comment">// 抽象组件，和keep-alive一样</span>  abstract: <span class="hljs-literal">true</span>,  render (h: <span class="hljs-built_in">Function</span>) &#123;    <span class="hljs-comment">// 获取包裹的内容</span>    <span class="hljs-keyword">let</span> children: any = <span class="hljs-keyword">this</span>.$slots.default    <span class="hljs-keyword">if</span> (!children) &#123;      <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-comment">// 把文本节点过滤掉</span>    children = children.filter(isNotTextNode)    <span class="hljs-comment">// 如果没有children 直接返回</span>    <span class="hljs-keyword">if</span> (!children.length) &#123;      <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-comment">// transition组件不能包裹多个，多个需要transition-group</span>    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">'production'</span> &amp;&amp; children.length &gt; <span class="hljs-number">1</span>) &#123;      warn(        <span class="hljs-string">'&lt;transition&gt; can only be used on a single element. Use '</span> +        <span class="hljs-string">'&lt;transition-group&gt; for lists.'</span>,        <span class="hljs-keyword">this</span>.$parent      )    &#125;    <span class="hljs-comment">// 获取传入的 props mode</span>    <span class="hljs-keyword">const</span> mode: string = <span class="hljs-keyword">this</span>.mode    <span class="hljs-comment">// warn invalid mode</span>    <span class="hljs-comment">// mode只能选择in-out 和 out-in</span>    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">'production'</span> &amp;&amp;      mode &amp;&amp; mode !== <span class="hljs-string">'in-out'</span> &amp;&amp; mode !== <span class="hljs-string">'out-in'</span>    ) &#123;      warn(        <span class="hljs-string">'invalid &lt;transition&gt; mode: '</span> + mode,        <span class="hljs-keyword">this</span>.$parent      )    &#125;    <span class="hljs-comment">// 第一个子节点</span>    <span class="hljs-keyword">const</span> rawChild: VNode = children[<span class="hljs-number">0</span>]    <span class="hljs-comment">// 如果 是根节点 或者父组件也是一个transition 则直接返回</span>    <span class="hljs-keyword">if</span> (hasParentTransition(<span class="hljs-keyword">this</span>.$vnode)) &#123;      <span class="hljs-keyword">return</span> rawChild    &#125;    <span class="hljs-comment">// 如果包裹的是keepalive 则会递归查找真实的节点,在这个demo里就是 p这个 vnode</span>    <span class="hljs-keyword">const</span> child: ?VNode = getRealChild(rawChild)    <span class="hljs-comment">// 没有则返回当前节点</span>    <span class="hljs-keyword">if</span> (!child) &#123;      <span class="hljs-keyword">return</span> rawChild    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._leaving) &#123;      <span class="hljs-keyword">return</span> placeholder(h, rawChild)    &#125;    <span class="hljs-comment">// 根据不同的情况生成一个 key</span>    <span class="hljs-keyword">const</span> id: string = <span class="hljs-string">`__transition-<span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>._uid&#125;</span>-`</span>    child.key = child.key == <span class="hljs-literal">null</span>      ? child.isComment        ? id + <span class="hljs-string">'comment'</span>        : id + child.tag      : isPrimitive(child.key)        ? (<span class="hljs-built_in">String</span>(child.key).indexOf(id) === <span class="hljs-number">0</span> ? child.key : id + child.key)        : child.ke    <span class="hljs-comment">// render函数其实就做了这么一件事情，把transition的props 和 函数钩子 扩展到当前 data里的 transition属性里。</span>    <span class="hljs-keyword">const</span> data: <span class="hljs-built_in">Object</span> = (child.data || (child.data = &#123;&#125;)).transition = extractTransitionData(<span class="hljs-keyword">this</span>)    <span class="hljs-keyword">const</span> oldRawChild: VNode = <span class="hljs-keyword">this</span>._vnode    <span class="hljs-keyword">const</span> oldChild: VNode = getRealChild(oldRawChild)    ...    <span class="hljs-keyword">return</span> rawChild  &#125;&#125;</code></pre><h3 id="实际控制动画的地方"><a href="#实际控制动画的地方" class="headerlink" title="实际控制动画的地方"></a>实际控制动画的地方</h3>　　<code>Vue</code>会根据不同的入口，挂载不同的<code>pacth</code>。<pre><code class="hljs javascript"><span class="hljs-comment">// runtime/index.js</span>Vue.prototype.__patch__ = inBrowser ? patch : noop</code></pre>　　而<code>patch</code>会根据平台的不同，加载不同的<code>platformModules</code>。而我们的<code>transition</code>就属于其中的一个模块。<pre><code class="hljs javascript"><span class="hljs-comment">// runtime/patch.js</span><span class="hljs-keyword">import</span> platformModules <span class="hljs-keyword">from</span> <span class="hljs-string">'web/runtime/modules/index'</span><span class="hljs-keyword">const</span> modules = platformModules.concat(baseModules)<span class="hljs-comment">// runtime/modules/transition.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> inBrowser ? &#123;  <span class="hljs-comment">// create hook的时候 会执行 _enter</span>  create: _enter,  activate: _enter,  remove (vnode: VNode, <span class="hljs-attr">rm</span>: <span class="hljs-built_in">Function</span>) &#123;    <span class="hljs-comment">/* istanbul ignore else */</span>    <span class="hljs-keyword">if</span> (vnode.data.show !== <span class="hljs-literal">true</span>) &#123;      leave(vnode, rm)    &#125; <span class="hljs-keyword">else</span> &#123;      rm()    &#125;  &#125;&#125; : &#123;&#125;</code></pre>　　然后会合并hooks。<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hooks = [<span class="hljs-string">'create'</span>, <span class="hljs-string">'activate'</span>, <span class="hljs-string">'update'</span>, <span class="hljs-string">'remove'</span>, <span class="hljs-string">'destroy'</span>]...<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; hooks.length; ++i) &#123;    cbs[hooks[i]] = []    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; modules.length; ++j) &#123;      <span class="hljs-keyword">if</span> (isDef(modules[j][hooks[i]])) &#123;        cbs[hooks[i]].push(modules[j][hooks[i]])      &#125;    &#125;  &#125;</code></pre>　　也就是说，在<code>web</code>端，执行<code>create</code>钩子函数的时候，实际上会走<code>_enter函数</code>。<pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enter</span> (<span class="hljs-params">vnode: VNodeWithData, toggleDisplay: ?(</span>) =&gt; <span class="hljs-title">void</span>) </span>&#123;  <span class="hljs-comment">// 拿到DOM对象</span>  <span class="hljs-keyword">const</span> el: any = vnode.elm  <span class="hljs-keyword">if</span> (isDef(el._leaveCb)) &#123;    el._leaveCb.cancelled = <span class="hljs-literal">true</span>    el._leaveCb()  &#125;  <span class="hljs-comment">// 自定义动画名字</span>  <span class="hljs-keyword">const</span> data = resolveTransition(vnode.data.transition)  ...  <span class="hljs-comment">// 拿到data上的各种配置</span>  <span class="hljs-keyword">const</span> &#123;    css,    type,   ...  &#125; = data  ...  <span class="hljs-comment">// 获取appear参数</span>  <span class="hljs-keyword">const</span> isAppear = !context._isMounted || !vnode.isRootInsert  <span class="hljs-keyword">if</span> (isAppear &amp;&amp; !appear &amp;&amp; appear !== <span class="hljs-string">''</span>) &#123;    <span class="hljs-keyword">return</span>  &#125;  <span class="hljs-comment">// 接下来就是各种根据配置参数定义Class</span>  <span class="hljs-keyword">const</span> startClass = isAppear &amp;&amp; appearClass    ? appearClass    : enterClass  <span class="hljs-keyword">const</span> activeClass = isAppear &amp;&amp; appearActiveClass    ? appearActiveClass    : enterActiveClass  <span class="hljs-keyword">const</span> toClass = isAppear &amp;&amp; appearToClass    ? appearToClass    : enterToClass    <span class="hljs-comment">// 拿到自定义的钩子</span>  <span class="hljs-keyword">const</span> beforeEnterHook = isAppear    ? (beforeAppear || beforeEnter)    : beforeEnter  <span class="hljs-keyword">const</span> enterHook = isAppear    ? (<span class="hljs-keyword">typeof</span> appear === <span class="hljs-string">'function'</span> ? appear : enter)    : enter  <span class="hljs-keyword">const</span> afterEnterHook = isAppear    ? (afterAppear || afterEnter)    : afterEnter  <span class="hljs-keyword">const</span> enterCancelledHook = isAppear    ? (appearCancelled || enterCancelled)    : enterCancelled    <span class="hljs-comment">// 自定义动画时长</span>  <span class="hljs-keyword">const</span> explicitEnterDuration: any = toNumber(    isObject(duration)      ? duration.enter      : duration  )  ...  <span class="hljs-keyword">const</span> expectsCSS = css !== <span class="hljs-literal">false</span> &amp;&amp; !isIE9  <span class="hljs-comment">// 组件设计用户自己控制动画结束API</span>  <span class="hljs-keyword">const</span> userWantsControl = getHookArgumentsLength(enterHook)  <span class="hljs-comment">// cb函数，会在后面insert的时候掉用</span>  <span class="hljs-keyword">const</span> cb = el._enterCb = once(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (expectsCSS) &#123;      removeTransitionClass(el, toClass)      removeTransitionClass(el, activeClass)    &#125;    <span class="hljs-keyword">if</span> (cb.cancelled) &#123;      <span class="hljs-keyword">if</span> (expectsCSS) &#123;        removeTransitionClass(el, startClass)      &#125;      enterCancelledHook &amp;&amp; enterCancelledHook(el)    &#125; <span class="hljs-keyword">else</span> &#123;      afterEnterHook &amp;&amp; afterEnterHook(el)    &#125;    el._enterCb = <span class="hljs-literal">null</span>  &#125;)  <span class="hljs-keyword">if</span> (!vnode.data.show) &#123;    <span class="hljs-comment">// 插入钩子函数insert</span>    mergeVNodeHook(vnode, <span class="hljs-string">'insert'</span>, () =&gt; &#123;      <span class="hljs-keyword">const</span> parent = el.parentNode      <span class="hljs-keyword">const</span> pendingNode = parent &amp;&amp; parent._pending &amp;&amp; parent._pending[vnode.key]      <span class="hljs-keyword">if</span> (pendingNode &amp;&amp;        pendingNode.tag === vnode.tag &amp;&amp;        pendingNode.elm._leaveCb      ) &#123;        pendingNode.elm._leaveCb()      &#125;      enterHook &amp;&amp; enterHook(el, cb)    &#125;)  &#125;  <span class="hljs-comment">// 开始和进入的动画控制</span>  beforeEnterHook &amp;&amp; beforeEnterHook(el)  <span class="hljs-keyword">if</span> (expectsCSS) &#123;    addTransitionClass(el, startClass)    addTransitionClass(el, activeClass)    nextFrame(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      removeTransitionClass(el, startClass)      <span class="hljs-keyword">if</span> (!cb.cancelled) &#123;        addTransitionClass(el, toClass)        <span class="hljs-keyword">if</span> (!userWantsControl) &#123;          <span class="hljs-keyword">if</span> (isValidDuration(explicitEnterDuration)) &#123;            setTimeout(cb, explicitEnterDuration)          &#125; <span class="hljs-keyword">else</span> &#123;            whenTransitionEnds(el, type, cb)          &#125;        &#125;      &#125;    &#125;)  &#125;</code></pre></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　<code>leave</code>过程和<code>enter</code>其实是一样的，所以真正执行动画的是我们写的 CSS 或者是 JavaScript 钩子函数，而 Vue 的 <transition> 只是帮我们很好地管理了这些 CSS 的添加/删除，以及钩子函数的执行时机。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端知识</tag>
      
      <tag>Vue</tag>
      
      <tag>源码解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器事件循环及消息队列</title>
    <link href="/2020/06/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%8F%8A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/2020/06/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%8F%8A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>　　事件循环的概念早就有了，只能感慨自己见识少。自己的思考方式还是偏向上层应用，还是得多看看软件设计基础。<br>　　事件循环系统由宿主提供，在浏览器里，参照<a href="https://html.spec.whatwg.org/#event-loops" target="_blank" rel="noopener">whatwg</a>。  </p><h3 id="什么是事件循环以及事件循环解决了什么问题"><a href="#什么是事件循环以及事件循环解决了什么问题" class="headerlink" title="什么是事件循环以及事件循环解决了什么问题"></a>什么是事件循环以及事件循环解决了什么问题</h3><p>　　按照规范来说，就是协调用户操作，脚本，渲染，网络等等事件的处理的机制。一个事件循环系统可以有一个或者多个任务队列。<br>　　浏览器从早期的单进程架构走向现在的多进程架构(多进程之间进程隔离，虽然占有空间变大，但是安全性和稳定性会变高)。我们打开一个 <code>chrome</code>的任务管理器。会发现一个<code>tab</code>页下，有多个进程在同时运行。包含浏览器进程、GPU进程、网络进程，音频进程、渲染进程（有些机制会复用同一个渲染进程）、插件进程等等。<br>　　就我们浏览一个网页而言，我们输入一个<code>uri</code>，渲染进程就会通知网络进程去下载资源。下载完毕之后就需要通知渲染进程进行渲染。而浏览器又是进程隔离的。只有渲染进程一个单进程在处理任务，这个时候就需要有一种机制来处理这种情况。也就是消息队列和事件循环。</p><h3 id="消息队列及使用消息队列的缺点"><a href="#消息队列及使用消息队列的缺点" class="headerlink" title="消息队列及使用消息队列的缺点"></a>消息队列及使用消息队列的缺点</h3><p>　　当浏览器遇到对应的输入，不同的进程会向自己的消息队列推送对应的任务。也会通过进程通信，向主线程的消息队<code>postTask</code>。<code>chrome</code>源码中，为不同的任务定义了不同的类型。</p><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskType</span> :</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> &#123;  kJavascriptTimer = <span class="hljs-number">10</span>&#125;</code></pre><p>　　页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。于是，有些任务的实效性就成了问题。</p><h3 id="微任务队列"><a href="#微任务队列" class="headerlink" title="微任务队列"></a>微任务队列</h3><p>　　为了解决实效性的问题，<code>V8</code>设计了微任务队列。在宏任务执行完成之后，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的产生的微任务队列。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端知识</tag>
      
      <tag>浏览器工作原理</tag>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP协议缓存|生鲜速递</title>
    <link href="/2020/06/12/HTTP%E5%8D%8F%E8%AE%AE%E7%BC%93%E5%AD%98%7C%E7%94%9F%E9%B2%9C%E9%80%9F%E9%80%92/"/>
    <url>/2020/06/12/HTTP%E5%8D%8F%E8%AE%AE%E7%BC%93%E5%AD%98%7C%E7%94%9F%E9%B2%9C%E9%80%9F%E9%80%92/</url>
    
    <content type="html"><![CDATA[<p>　　<code>HTTP1.1协议</code>加入了缓存控制。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>　　缓存是一种有效的缓解服务器端压力，提升性能的手段。HTTP定义了三种控制缓存的基本机制：新鲜度(Freshness)，验证(Validation)和失效(Expiration)。</p><h3 id="不同种类的缓存"><a href="#不同种类的缓存" class="headerlink" title="不同种类的缓存"></a>不同种类的缓存</h3><p>　　缓存的种类有很多,其大致可归为两类：私有与共享缓存。私有缓存只能作用单独的用户，比如浏览器。而共享缓存可以被多个用户使用。比如代理缓存，CDN,反向代理，负载均衡等。</p><h3 id="生鲜速递"><a href="#生鲜速递" class="headerlink" title="生鲜速递"></a>生鲜速递</h3><p>　　我们用一个生鲜速递的例子来描述缓存。<br>　　夏天到了，我们打开冰箱，想找瓶快乐水。但是发现没有，于是我们天猫超市一波，天猫超市给我们送来了一箱快乐水。于是，冰箱成了缓存，我成了浏览器，天猫超市成了服务器，汽水就是资源。<br><img src="/imges/%E8%B6%85%E5%B8%82.png" srcset="/img/loading.gif" alt=""><br>　　我们都知道，有的商品是有保质期的（新鲜度），或者是商家自己打包的商品，你需要询问商家是不是最新的。保质期过了（失效），你可能会把它丢掉，或者你舍不得丢，想继续吃，于是问下商家，还可以吃吗？（验证）。又或者有些东西开袋即食，是不可以保存的。你可以发现， <code>HTTP协议</code>，里的<code>Cache-Control</code>都可以找到对应的字段来处理这些问题。<br>　　<code>max-age</code>对应着保质期。<code>no_store</code>对应着开袋即食，<code>no_cache</code>代表着你使用商品前需要询问下商家。<code>must-revalidate</code>对应着商品过期后，必须询问商家。<code>max-stale</code>对应着商家允许你在过期时间后继续消费商品。</p><h3 id="Cache-Control的缺陷以及解决方案"><a href="#Cache-Control的缺陷以及解决方案" class="headerlink" title="Cache-Control的缺陷以及解决方案"></a>Cache-Control的缺陷以及解决方案</h3><p>　　浏览器用“Cache-Control”做缓存控制只能是刷新数据，不能很好地利用缓存数据，又因为缓存会失效，使用前还必须要去服务器验证是否是最新版。于是你必须发送两个请求。先发送一个<code>HEAD</code>请求，如果过期了，再发送一个<code>GET</code>请求。  </p><p>　　针对这种情况,<code>HTTP协议</code>加入了条件请求，让服务也有了控制缓存的权限。当客户端发起一个请求时，缓存检索到已有一个对应的陈旧资源（缓存副本），则缓存会先将此请求附加一个<code>If-None-Match</code>头，然后发给目标服务器，以此来检查该资源副本是否是依然还是算新鲜的，若服务器返回了 304 (Not Modified)（该响应不会有带有实体信息），则表示此资源副本是新鲜的，这样一来，可以节省一些带宽。若服务器通过 <code>If-None-Match</code> 或 <code>If-Modified-Since</code>判断后发现已过期，那么会带有该资源的实体内容返回。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端知识</tag>
      
      <tag>浏览器工作原理</tag>
      
      <tag>HTTP 协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符集 和 JavaScript</title>
    <link href="/2020/06/11/%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8CJavaScript/"/>
    <url>/2020/06/11/%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8CJavaScript/</url>
    
    <content type="html"><![CDATA[<p>　　JavaScript源代码文本支持所有的 <code>Unicode</code> 字符集。在 <code>ECMA262 10th</code>上，定义的是 <code>U+0000 to U+10FFFF</code> 区间。在此记录下了解 <code>Unicode</code>  的过程。  </p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>　　<code>Unicode</code> 的出现，是想让全世界统一一套字符集（不过最近疯狂在弄Emoji），当时在做同样事情的组织还有 <code>UCS</code> 团队。<code>Unicode</code> 为每一个字符规定了 <code>code point</code>,也就是码点。它从0开始，为每个符号指定一个编号。使用 <code>U+</code> 跟在后面的十六进制数来表示。<code>U+597D</code>，JavaScript允许直接用码点表示Unicode字符，比如 <code>\u597D</code>。<code>Unicode</code> 按区间来划分。最前面的65536个字符位，称为BMP，写成16进制就是从<code>U+0000</code>到<code>U+FFFF</code>。所有最常见的字符都放在这个平面。在<code>JS</code>中也最好只使用这些字符。</p><h3 id="UTF-8与UTF-16，UTF-32"><a href="#UTF-8与UTF-16，UTF-32" class="headerlink" title="UTF-8与UTF-16，UTF-32"></a>UTF-8与UTF-16，UTF-32</h3><p>　　<code>Unicode</code>只是规定了码点，但是并没有规定具体的编码形式。也就是说，最直观的就是 <code>UTF-32</code>,每个码点使用四个字节表示，字节内容一一对应码点。比如字母<code>A</code> 就是 <code>\u0041</code>。在内存中就是<code>0x00000041</code>。虽然这种方式查找效率高，但是对于大部分小于<code>U+FFFF</code>的字节来说，文件会大4倍。于是 <code>utf-8</code> 和 <code>utf-16</code> 这种可变长度就受到了大家亲睐。  </p><ul><li>utf-8<br>　　UTF-8是一种变长的编码方法，字符长度从1个字节到4个字节不等。UTF-8 的编码规则很简单，只有二条：  </li></ul><ol><li><p>对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。  </p></li><li><p>对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。  </p></li></ol><ul><li><p>utf-16<br>utf-16编码应该是最优秀了的，因为同时结合了定长和变长两种编码方法的特点。它的编码规很简单：基本平面的字符占用2个字节，辅助平面的字符占用4个字节。所以很好的平衡了时间和空间。  </p><h3 id="字符集和-JavaScript"><a href="#字符集和-JavaScript" class="headerlink" title="字符集和 JavaScript"></a>字符集和 JavaScript</h3><p>　　早期的<code>JS</code>是采用的<code>UCS-2</code>编码，使用2个字节表示已经有码点的字符。所以随着 <code>Unicode</code>的发展，2个字节已经不足以表达所有的码点。导致<code>JavaScript</code>的字符函数都受到了影响，无法返回正确结果。  </p><pre><code class="javascript"><span class="keyword">let</span> s = <span class="string">'𝄆'</span>s.length <span class="comment">// 2</span></code></pre></li></ul><p>　　好在 <code>ES6</code> 字符串对于字符进行了加强。关于超过<code>\uFFFF</code>的码点，可以这样表示<code>\u{1D106}</code>。但是，为了保持兼容，length属性还是原来的行为方式。为了得到字符串的正确长度，可以用下面的方式。<br>　　<code>Array.from(string).length</code>。  </p><p>　　也新增了几个专门处理4字节码点的函数.</p><pre><code class="javascript"><span class="built_in">String</span>.fromCodePoint()：从Unicode码点返回对应字符<span class="built_in">String</span>.prototype.codePointAt()：从字符返回对应的码点<span class="built_in">String</span>.prototype.at()：返回字符串给定位置的字符</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>前端知识</tag>
      
      <tag>计算机基础</tag>
      
      <tag>编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP协议是什么以及不是什么</title>
    <link href="/2020/06/09/HTTP%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%BB%80%E4%B9%88%E4%BB%A5%E5%8F%8A%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2020/06/09/HTTP%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%BB%80%E4%B9%88%E4%BB%A5%E5%8F%8A%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h3 id="HTTP协议是什么？"><a href="#HTTP协议是什么？" class="headerlink" title="HTTP协议是什么？"></a>HTTP协议是什么？</h3><p>　　超文本传输协议。是一个用于传输超媒体文档（例如 HTML）的<strong>应用层</strong>协议。<strong>是纯粹的文本协议</strong>，<strong>可以在任何可靠的传输层上使用</strong>。（ HTTP/2 基于 Google 的 SPDY 协议，HTTP/3 基于 Google 的 QUIC 协议），但是通常是基于 TCP/IP 层，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 如果建立在 TCP 的基础上，那么就遵循Request-Response 的模式。也就是说通讯必定是由用户代理首先发起的。</p><p><img src="/imges/HTTP&layers.png" srcset="/img/loading.gif" alt=""><br>　　HTTP被设计于20世纪90年代初期，在最开始设计的时候，只是用于从服务器获取文档，所以只定义了 <code>GET</code> 操作，在后来的日子里，随着计算机媒体的技术的发展，出现了 <code>JPEG</code>，<code>MP3</code> 音乐等，于是有了 <code>HTTP/1.0</code> 。  </p><p>　　<code>HTTP/1.0</code>形式上已经和现在的 <code>HTTP/1.1</code>差别不大了。  </p><ol><li>增加了 HEAD、POST 等新方法；</li><li>增加了响应状态码，标记可能的错误原因；</li><li>引入了协议版本号概念；</li><li>引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；</li><li><strong>传输的数据</strong>不再仅限于文本（只是传输的数据不仅限于文本）。</li></ol><p>　　但是这个时候<code>HTTP</code>还是社区维护的状态，大家随意修改。浏览器各自有各自的实现方式，直到浏览器大战的95年后，<code>HTTP</code> 才正式有了一份文档, <a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">编号为 RFC 2616</a>。</p><p>　　从版本号我们就可以看到<code>HTTP/1.1</code> 是对 <code>HTTP/1.0</code>的小幅度修正。但是它是一份正式的标准，也就是说，大部分正规的软件会参考标准来做东西（我没有说IE，真的）。  </p><p>　　HTTP/1.1 主要的变更点有：  </p><ol><li>增加了 PUT、DELETE 等新的方法；</li><li>增加了缓存管理和控制；</li><li>明确了连接管理，允许持久连接；</li><li>允许响应数据分块（chunked），利于传输大文件；</li><li>强制要求 Host 头，让互联网主机托管成为可能。</li></ol><p>　　除此之外，<code>HTTP</code> 协议还规定报文必须有 <code>header</code>，但可以没有 <code>body</code>，而且在<code>header</code> 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。如下图所示：<br><img src="/imges/httpmessage.png" srcset="/img/loading.gif" alt=""> </p><p>　　我们可以使用<code>Node</code>来模拟下用户代理已经服务器。</p><ul><li>client端<pre><code class="hljs javascript"><span class="hljs-comment">// client</span><span class="hljs-comment">// 创建一个TCP链接后，使用纯文本传输内容，这就是HTTP协议</span><span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">'net'</span>);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transforHeader</span>(<span class="hljs-params">headers</span>) </span>&#123;    <span class="hljs-keyword">let</span> test = <span class="hljs-built_in">Object</span>.keys(headers).map(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> key + <span class="hljs-string">': '</span> + headers[key]    &#125;).join(<span class="hljs-string">'\r\n'</span>)    <span class="hljs-keyword">return</span> test;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">option, cb1, cb2</span>) </span>&#123;    <span class="hljs-keyword">let</span> client = net.createConnection(&#123;        port: option.port || <span class="hljs-number">8080</span>    &#125;, () =&gt; &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'服务器链接成功'</span>)        client.write(option.method + <span class="hljs-string">' / HTTP/1.1\r\n'</span> + transforHeader(option.headers) + <span class="hljs-string">'\r\n\r\n'</span> + <span class="hljs-string">'123'</span>);    &#125;);    client.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(data)        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(data))        cb1(data.toString())        client.end();    &#125;);    client.on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'断开与服务器的连接'</span>);    &#125;);    client.on(<span class="hljs-string">'error'</span>, (err) =&gt; &#123;        cb2(err)        <span class="hljs-built_in">console</span>.log(err)    &#125;)&#125;request(&#123;<span class="hljs-attr">port</span>:<span class="hljs-number">8080</span>, <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>, <span class="hljs-attr">headers</span>: &#123;<span class="hljs-string">'Host'</span>: <span class="hljs-string">'localhost:8080'</span>,<span class="hljs-string">'Accept'</span>: <span class="hljs-string">'accept-encoding: gzip, deflate, br'</span>,<span class="hljs-string">'content-length'</span>: <span class="hljs-string">'3'</span>&#125;&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cb1</span>(<span class="hljs-params">data</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(data)&#125;,<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cb2</span>(<span class="hljs-params">err</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(err)&#125;)</code></pre></li><li>server端<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>)<span class="hljs-keyword">let</span> httpServer = http.createServer( (req, res) =&gt; &#123;    <span class="hljs-keyword">let</span>  body = <span class="hljs-string">""</span>;    <span class="hljs-built_in">console</span>.log(req.headers)    req.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>) </span>&#123;      body += chunk;    &#125;);    res.writeHead(<span class="hljs-number">200</span>, &#123;<span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/plain'</span>&#125;);    res.write(<span class="hljs-string">"Hello World"</span>);    req.on(<span class="hljs-string">'end'</span>, () =&gt; &#123;       <span class="hljs-built_in">console</span>.log(body)       res.end()    &#125;) &#125;).listen(<span class="hljs-number">8080</span>);</code></pre>　　测试过程中，发现<code>Content-length</code> 是必传的(非chunk模式)，而且需要自己去计算。但是并没有如文档所描述的那样，必须有 <code>host</code> 头. 可能和具体的<code>server</code>实现有关系。</li></ul><h3 id="HTTP协议不是什么？"><a href="#HTTP协议不是什么？" class="headerlink" title="HTTP协议不是什么？"></a>HTTP协议不是什么？</h3><p>  <code>HTTP</code>不是单独的实体，不能单独存在，它基于可靠的传输层协议，也有一些协议基于它。<code>HTTP</code>专门用来在两点之间传输数据，不能用于广播、寻址或路由。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端知识</tag>
      
      <tag>浏览器工作原理</tag>
      
      <tag>HTTP 协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端之外</title>
    <link href="/2019/02/28/%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%A4%96/"/>
    <url>/2019/02/28/%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%A4%96/</url>
    
    <content type="html"><![CDATA[<p>　　最近看到阮一峰老师分享的一篇文章<a href="http://rubyhacker.com/blog2/20150917.html" target="_blank" rel="noopener">失传的计算机科学</a>深有同感，如今越来越标准化的开发方式和工具使得开发越来越容易，你很难想象一个使用<code>Vue-Cli</code>工具的前端开发居然不明白<code>webpack</code>是怎么工作的。更奇怪的是，他们任然能够出色的完成需求。<br>软件的开发成本理应越来越低，软件开发从一个刀耕火种的年代一路走到今天，前辈们总结出来的经验和智慧变成工具，从一开始的拖拖拽拽到现在机器学习，工具已经可以强大到可以替代大部分重复劳动的工种。<br>　　但是问题就在这里，现在的工具还不够成熟。<br>　　你无法忽视网络协议，无法忽视性能，无法忽视安全。<br>　　如果有一天，工具能够解决这些问题了。我们应该感觉到开心，大可不必担心自己被替代。<br>因为，可以转行做产品经理啊。(｡･∀･)ﾉﾞ&quot;</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
