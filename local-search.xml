<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>设计模式-创建型</title>
    <link href="/2021/03/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
    <url>/2021/03/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>　　创建型模式提供了创建对象的机制， 能够提升已有代码的灵活性和可复用性。  </p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p><img src="/imges/FactoryPattern.png" srcset="/img/loading.gif" alt=""><br>　　工厂模式将构造函数和创建者分离</p><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">slide</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(name) &#123;    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">'slide'</span>  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Click</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(name) &#123;    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">'click'</span>  &#125;&#125;<span class="hljs-comment">// 工厂类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Creator</span></span>&#123;  getCaptcha(name) &#123;    <span class="hljs-keyword">if</span>(name === <span class="hljs-string">'slide'</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Slide();    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(name === <span class="hljs-string">'click'</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Click();    &#125;  &#125;&#125;<span class="hljs-keyword">let</span> creator = <span class="hljs-keyword">new</span> Creator();<span class="hljs-keyword">let</span> slide = creator.getCaptcha(<span class="hljs-string">'slide'</span>)</code></pre><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p><img src="/imges/AbstractFactory.png" srcset="/img/loading.gif" alt=""><br>　　抽象工厂模式是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> AbstractFactory &#123;  createChair(): AbstractChair,  createSofa(): AbstractSofa,  createCoffeeTable(): AbstractCoffeeTable&#125;<span class="hljs-keyword">interface</span> AbstractChair &#123;  siteDown(): <span class="hljs-built_in">void</span>&#125;<span class="hljs-keyword">interface</span> AbstractSofa &#123;  lieDown(): <span class="hljs-built_in">void</span>&#125;<span class="hljs-keyword">interface</span> AbstractCoffeeTable &#123;  drinkCoffee(): <span class="hljs-built_in">void</span>&#125;<span class="hljs-keyword">class</span> AmericanFactory <span class="hljs-keyword">implements</span> AbstractFactory &#123;  createChair(): AmericanChair &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AmericanChair();  &#125;  createSofa(): AmericanSofa &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AmericanSofa();  &#125;  createCoffeeTable(): AmericanCoffeeTable &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AmericanCoffeeTable();  &#125;&#125;<span class="hljs-keyword">class</span> AmericanChair <span class="hljs-keyword">implements</span> AbstractChair &#123;  siteDown() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'美式坐法'</span>)  &#125;&#125;<span class="hljs-keyword">class</span> AmericanSofa <span class="hljs-keyword">implements</span> AbstractSofa&#123;  lieDown() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'美式躺法'</span>)  &#125;&#125;<span class="hljs-keyword">class</span> AmericanCoffeeTable  <span class="hljs-keyword">implements</span> AbstractCoffeeTable&#123;  drinkCoffee() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'美式喝法'</span>)  &#125;&#125;</code></pre><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><img src="/imges/SingleInstance.png" srcset="/img/loading.gif" alt=""><br>　　单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p><h4 id="Vue插件"><a href="#Vue插件" class="headerlink" title="Vue插件"></a>Vue插件</h4><p>　　在<code>JS</code>中比较<code>hack</code>。在<code>Vuex</code>中，<code>Vuex</code>如果<code>use</code>了两次，就会提示错误。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> Vue <span class="hljs-comment">// bind on install</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">install</span> (<span class="hljs-params">_Vue</span>) </span>&#123;  <span class="hljs-keyword">if</span> (Vue &amp;&amp; _Vue === Vue) &#123;    <span class="hljs-keyword">if</span> (__DEV__) &#123;      <span class="hljs-built_in">console</span>.error(        <span class="hljs-string">'[vuex] already installed. Vue.use(Vuex) should be called only once.'</span>      )    &#125;    <span class="hljs-keyword">return</span>  &#125;  Vue = _Vue  applyMixin(Vue)&#125;</code></pre><h4 id="一个简单的示例代码"><a href="#一个简单的示例代码" class="headerlink" title="一个简单的示例代码"></a>一个简单的示例代码</h4><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SingleInstance</span>(<span class="hljs-params"></span>) </span>&#123;&#125;SingleInstance.prototype.getInstance = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">// 定义自由变量instance，模拟私有变量</span>  <span class="hljs-keyword">let</span> instance = <span class="hljs-literal">null</span>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-comment">// 判断自由变量是否为null</span>      <span class="hljs-keyword">if</span>(!instance) &#123;          <span class="hljs-comment">// 如果为null则new出唯一实例</span>          instance = <span class="hljs-keyword">new</span> SingleInstance()      &#125;      <span class="hljs-keyword">return</span> instance    &#125;&#125;)()</code></pre><h3 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h3><p><img src="/imges/builder.png" srcset="/img/loading.gif" alt=""><br>　　生成器模式是一种创建型设计模式， 使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。</p><pre><code class="hljs typescript"><span class="hljs-comment">// 按一定的步骤生成车</span><span class="hljs-keyword">interface</span> Builder &#123;  buildEngine(): <span class="hljs-built_in">void</span>;  buildSteering(): <span class="hljs-built_in">void</span>;  buildFrame(): <span class="hljs-built_in">void</span>;  buildTire(): <span class="hljs-built_in">void</span>;  buildOmnirange(): <span class="hljs-built_in">void</span>;&#125;<span class="hljs-comment">// 具体生成器 -&gt; 生成奔驰车</span><span class="hljs-keyword">class</span> BenzBuilder <span class="hljs-keyword">implements</span> Builder&#123;  <span class="hljs-keyword">private</span> car: BenzCar;  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">this</span>.reset();  &#125;  reset() &#123;    <span class="hljs-keyword">this</span>.car = <span class="hljs-keyword">new</span> BenzCar();  &#125;  buildEngine(): <span class="hljs-built_in">void</span> &#123;    <span class="hljs-keyword">this</span>.car.parts.push(<span class="hljs-string">'buildEngine'</span>);  &#125;  buildSteering(): <span class="hljs-built_in">void</span> &#123;    <span class="hljs-keyword">this</span>.car.parts.push(<span class="hljs-string">'buildSteering'</span>);  &#125;  buildFrame(): <span class="hljs-built_in">void</span> &#123;    <span class="hljs-keyword">this</span>.car.parts.push(<span class="hljs-string">'buildFrame'</span>);  &#125;  buildTire(): <span class="hljs-built_in">void</span> &#123;    <span class="hljs-keyword">this</span>.car.parts.push(<span class="hljs-string">'buildTire'</span>);  &#125;  <span class="hljs-comment">// Pro的车才有</span>  buildOmnirange(): <span class="hljs-built_in">void</span> &#123;    <span class="hljs-keyword">this</span>.car.parts.push(<span class="hljs-string">'buildOmnirange'</span>);  &#125;  getProduct(): BenzCar &#123;    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">this</span>.car;    <span class="hljs-keyword">this</span>.reset();    <span class="hljs-keyword">return</span> result;  &#125;&#125;<span class="hljs-comment">// 具体的车类</span><span class="hljs-keyword">class</span> BenzCar &#123;  <span class="hljs-keyword">public</span> parts: <span class="hljs-built_in">string</span>[] = [];  <span class="hljs-comment">// 公共方法</span>  <span class="hljs-keyword">public</span> listParts(): <span class="hljs-built_in">void</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Product parts: <span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.parts.join(<span class="hljs-string">', '</span>)&#125;</span>\n`</span>);  &#125;&#125;<span class="hljs-comment">// 主管类</span><span class="hljs-keyword">class</span> Director &#123;  <span class="hljs-keyword">private</span> builder: Builder;  <span class="hljs-keyword">public</span> setBuilder(builder: Builder): <span class="hljs-built_in">void</span> &#123;      <span class="hljs-keyword">this</span>.builder = builder;  &#125;  <span class="hljs-keyword">public</span> buildBaseProduct(): <span class="hljs-built_in">void</span> &#123;      <span class="hljs-keyword">this</span>.builder.buildEngine();      <span class="hljs-keyword">this</span>.builder.buildFrame();      <span class="hljs-keyword">this</span>.builder.buildSteering();      <span class="hljs-keyword">this</span>.builder.buildTire();  &#125;  <span class="hljs-keyword">public</span> buildProProduct(): <span class="hljs-built_in">void</span> &#123;    <span class="hljs-keyword">this</span>.builder.buildEngine();    <span class="hljs-keyword">this</span>.builder.buildFrame();    <span class="hljs-keyword">this</span>.builder.buildSteering();    <span class="hljs-keyword">this</span>.builder.buildTire();    <span class="hljs-keyword">this</span>.builder.buildOmnirange();  &#125;&#125;<span class="hljs-keyword">const</span> director = <span class="hljs-keyword">new</span> Director();<span class="hljs-keyword">const</span> builder = <span class="hljs-keyword">new</span> BenzBuilder();director.setBuilder(builder);director.buildBaseProduct();builder.getProduct().listParts();</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装饰器模式</title>
    <link href="/2021/03/21/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/03/21/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>　　装饰模式是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</p><h3 id="ES7"><a href="#ES7" class="headerlink" title="ES7"></a>ES7</h3><p>　　<code>ES7</code>支持了装饰器语法。</p><pre><code class="hljs javascript">@decorator<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> </span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;    @decorator    run() &#123;&#125;&#125;</code></pre><p>　　和<code>class</code>一样，只是语法糖。通过<code>Object.defineProperty</code>方法，在类或者方法上加以“装饰“。所以会有一些<code>Babel</code>的插件方便在低版本浏览器支持这种语法。（所以如果不支持<code>Object.defineProperty</code>那就没办法了。😭可恶的我还要考虑IE8）</p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>　　装饰器这种元编程语法，还是挺好使的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>适配器模式</title>
    <link href="/2021/03/21/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/03/21/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>　　适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。</p><h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p>　　在<code>axios</code>里，可以很明显的看到这种适配模式。<code>axios</code>里最终请求都是到<code>request</code>方法。然后返回一个<code>Promise</code>。</p><pre><code class="hljs javascript">Axios.prototype.request = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">config</span>) </span>&#123;  ...  <span class="hljs-keyword">try</span> &#123;    promise = dispatchRequest(newConfig);  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);  &#125;&#125;</code></pre><p>　　最终，都是通过<code>dispatchRequest</code>来发送请求。</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> adapter = config.adapter || defaults.adapter;<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatchRequest</span>(<span class="hljs-params">config</span>) </span>&#123;  <span class="hljs-keyword">return</span> adapter(config).then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onAdapterResolution</span>(<span class="hljs-params">response</span>) </span>&#123;    throwIfCancellationRequested(config);    <span class="hljs-comment">// Transform response data</span>    response.data = transformData(      response.data,      response.headers,      config.transformResponse    );    <span class="hljs-keyword">return</span> response;  &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onAdapterRejection</span>(<span class="hljs-params">reason</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!isCancel(reason)) &#123;      throwIfCancellationRequested(config);      <span class="hljs-comment">// Transform response data</span>      <span class="hljs-keyword">if</span> (reason &amp;&amp; reason.response) &#123;        reason.response.data = transformData(          reason.response.data,          reason.response.headers,          config.transformResponse        );      &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(reason);  &#125;);&#125;</code></pre><p>　　如果没有在<code>config</code>里传入自定义的适配器，就使用默认的适配器。默认的配置器会去判断<code>XMLHttpRequest</code>是否存在，存在就使用<code>xhr</code>,否则使用<code>http</code>这个库。来磨平浏览器和<code>Node</code>d=端的差异。所以axios浏览器端是只支持<code>xhr</code>的吗😐。  </p><pre><code class="hljs javascript"><span class="hljs-comment">// defaults.js</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDefaultAdapter</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">var</span> adapter;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> XMLHttpRequest !== <span class="hljs-string">'undefined'</span>) &#123;    <span class="hljs-comment">// For browsers use XHR adapter</span>    adapter = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./adapters/xhr'</span>);  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> process !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-built_in">Object</span>.prototype.toString.call(process) === <span class="hljs-string">'[object process]'</span>) &#123;    <span class="hljs-comment">// For node use HTTP adapter</span>    adapter = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./adapters/http'</span>);  &#125;  <span class="hljs-keyword">return</span> adapter;&#125;</code></pre><h3 id="理解"><a href="#理解" class="headerlink" title="理解　　"></a>理解　　</h3><p>　　适配器对外暴露接口一致，允许内部有不同的逻辑</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMA-执行上下文</title>
    <link href="/2021/02/20/ECMA-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <url>/2021/02/20/ECMA-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    
    <content type="html"><![CDATA[<p>额，这个分享其实在12月份就做了，但是一直没来得及整理。现在整理下，也算是回顾下吧。在开篇之前，需要先记住下面两个概念，作用域和可执行环境。然后再来说说执行上下文，也就是执行环境。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>　　为什么要有作用域?为了确定哪些变量，函数，对象可以访问，哪些不可以访问。所以作用域的作用就是定义在运行时代码中的某些特定部分中变量，函数和对象的可访问性。<br>　　作用域有两种实现，一种是词法作用域，一种是动态作用域。<code>javascript</code>使用的便是词法作用域。词法作用域的特征就是在静态词法分析阶段就决定了数据的可访问性。词法环境是词法作用域这一概念的运行期概念。我们在上一次<a href="https://lucienstar.github.io/2020/11/13/ECMA-%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83/" target="_blank" rel="noopener">ECMA 词法环境</a>有介绍到这部分的内容。</p><h3 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h3><p>　　一个执行环境由三部分组成</p><ol><li>词法环境组件:指定一个词法环境对象，用于解析该执行环境内的代码创建的标识符引用</li><li>变量环境组件:指定一个词法环境对象，其环境数据用于保存由该执行环境内的代码通过 VariableStatement 和 FunctionDeclaration 创建的绑定</li><li>this 绑定: 指定该执行环境内的 ECMA 脚本代码中 this 关键字所关联的值</li></ol><h3 id="可执行代码"><a href="#可执行代码" class="headerlink" title="可执行代码"></a>可执行代码</h3><p>　　ECMA5共有3种可执行代码，Eval比较复杂，暂且不说。当控制流进入可执行代码的时候，就会有产生一个执行环境</p><ol><li>全局代码</li><li>Eval 代码</li><li>函数代码</li></ol><h3 id="全局代码"><a href="#全局代码" class="headerlink" title="全局代码"></a>全局代码</h3><p>　　当控制流进入全局代码的执行环境时，执行以下步骤：</p><ul><li>初始化执行环境。</li><li>将 变量环境组件设置为全局环境(一个outer为null的特殊的词法环境，环境记录项是对象环境记录项)。</li><li>将 词法环境组件设置为全局环境。</li><li>将 this绑定设置为全局对象。</li><li>执行声明式绑定初始化化步骤:当在一个执行环境下评估一段 ECMA 脚本时，变量和函数定义会以绑定的形式添加到这个 变量环境组件 的环境记录中。对于函数代码，参数也同样会以绑定的形式添加到这个 变量环境组件 的环境记录中。针对以下例子， </li></ul><p><img src="/imges/excute_example1.png" srcset="/img/loading.gif" alt="">  </p><p>　　在进去全局代码，还没有执行函数的时候，会产生如下执行环境<br><img src="/imges/excute_example2.png" srcset="/img/loading.gif" alt="">   </p><h3 id="函数代码"><a href="#函数代码" class="headerlink" title="函数代码"></a>函数代码</h3><p>　　当控制流根据一个函数对象 F、调用者提供的 thisArg 以及调用者提供的 argumentList，进入函数代码的执行环境时，执行以下步骤： </p><ol><li>如果函数代码是严格模式下的代码，设 this 绑定 为 thisArg(代表函数的 apply，call，bind 等函数的设置 this 绑定的参数)。</li><li>否则如果 thisArg 是 null 或 undefined，则设 this 绑定 为全局对象。否则如果 Type(thisArg) 的结果不为 Object，则设 this 绑定 为 ToObject(thisArg)。</li><li>否则设 this 绑定 为 thisArg。<br>以 F 的 [[Scope]] 内部属性(scope保存了当前的词法环境)为参数调用 NewDeclarativeEnvironment，并令 localEnv 为调用的结果。</li><li>设 词法环境组件 为 localEnv。</li><li>设 变量环境组件 为 localEnv。</li><li>令 code 为 F 的 [[Code]] 内部属性的值。</li><li>使用函数代码 code 和 argumentList 执行声明式绑定初始化化步骤。<br>　　还是上面那个例子，在执行函数的时候，会产生如下效果。这里图画得不太好，注意区分词法分析阶段和执行阶段。我这里画在一起了。<br><img src="/imges/excute_example3.png" srcset="/img/loading.gif" alt=""> </li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>前端知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMA 词法环境</title>
    <link href="/2020/11/13/ECMA-%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83/"/>
    <url>/2020/11/13/ECMA-%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<blockquote><p>为下一次分享做准备，此为可执行代码与执行环境第一篇</p></blockquote><h3 id="我们尝试解释一种行为"><a href="#我们尝试解释一种行为" class="headerlink" title="我们尝试解释一种行为"></a>我们尝试解释一种行为</h3><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(a)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">var</span> a = <span class="hljs-number">5</span>;  foo()&#125;bar()<span class="hljs-comment">// 分割线</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(a);  &#125;  foo();&#125;<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;bar();</code></pre><h3 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h3><p>　　词法环境也是一种规范类型。<br>　　作用: 词法环境是一个用于定义特定变量和函数标识符在 ECMAScript 代码的词法嵌套结构上关联关系<br>　　创建: 通常词法环境会与 ECMAScript 代码诸如 FunctionDeclaration、WithStatement 或者 TryStatement 的 Catch 块这样的特定句法结构相联系，且类似代码每次执行都会有一个新的词法环境被创建出来。（ES6 新增块语句）。<br>　　结构: 一个词法环境由一个环境记录项和可能为空的外部词法环境引用构成。可以记作:</p><pre><code class="hljs javascript">Lexical Environments = &#123;  EnvironmentRecord,  outer&#125;</code></pre><h3 id="环境记录项"><a href="#环境记录项" class="headerlink" title="环境记录项"></a>环境记录项</h3><p>　　环境记录项记录了在其关联的词法环境范围中创建的标识符绑定。<br>　　在 ES5 中，共有两类环境记录项：声明式环境记录项和对象式环境记录项。声明式环境记录项用于定义那些将标识符与语言值直接绑定的 ECMA 脚本语法元素，例如 函数定义、变量定义 以及 Catch 语句。对象式环境记录项用于定义那些将标识符与具体对象的属性绑定的 ECMA 脚本元素，例如 Program 以及 WithStatement 表达式。</p><h3 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h3><p>　　全局环境是一种 outer 为 null 的词法环境。全局环境的环境数据是一个对象环境数据，该环境数据使用全局对象（Realms:唯一的全局对象在控制进入任何执行环境前被创建。）作为绑定对象。</p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><blockquote><p>代码分块带来的语法效果是信息隐蔽，信息隐蔽，指的是变量或成员的可见性问题。而这个可见性区间，被称作作用域。当这个域是通过静态词法分析而得出的时候，它就被称作词法作用域。词法环境是词法作用域这一概念的运行期概念，在引擎执行时映射成环境记录项 ——周爱民　　</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>前端知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMA 规范类型之引用类型</title>
    <link href="/2020/11/02/ECMA-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <url>/2020/11/02/ECMA-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>　　最近学习有些怠惰了，一个月一篇总结博客有些延迟，也就是这个月要发两篇。最近在公司做了一次重学前端的分享。讲解的ECMA 引用类型对函数调用this的影响，对当时有些情况做些补充。</p><h3 id="ECMA-规范类型-ES5"><a href="#ECMA-规范类型-ES5" class="headerlink" title="ECMA 规范类型(ES5)"></a>ECMA 规范类型(ES5)</h3><p>　　ECMA分为两种类型，一种就是我们前端常熟悉的语言类型，也就是 <code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>String</code>、<code>Number</code>、<code>Object</code>。还有一种类型，称之为规范类型。规范类型包括引用、列表、完结、属性描述式、属性标示、词法环境、 环境纪录。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>　　我们尝试从 <code>delete</code> 开始说起。<code>delete</code>在删除什么？  </p><pre><code class="hljs javascript"><span class="hljs-keyword">delete</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 删除值</span><span class="hljs-keyword">delete</span> x; <span class="hljs-comment">// 删除变量</span><span class="hljs-keyword">delete</span> obj.x; <span class="hljs-comment">// 删除表达式</span></code></pre><p>　　对于一门编译型语言来说，所谓“0”，就是上面所述的一个值，它可以是基础值（Primitive values），也可以是数值类型。但如果将这个问题上升到编译之前的、所谓语法分析的阶段，那么“0”就会被称为一个记号（Tokens）。一个记号是没有语义的，记号既可以是语言能识别的，也可以是语言不能识别的。唯有把这二者同时纳入语言范畴，那么这个语言才能识别所谓的“语法错误”。所以<code>delelet</code>这个操作的正式语法设计并不是“删除某个东西”，而是“删除一个表达式的结果”：  </p><pre><code class="hljs javascript"><span class="hljs-keyword">delete</span> UnaryExpression</code></pre><p>　　在 JavaScript 中，有两个东西可以被执行并存在执行结果值（Result），包括语句和表达式。比如你用<code>eval()</code>来执行一个字符串，那么事实上，你执行的是一个语句，并返回了语句的值；而如果你使用一对括号来强制一个表达式执行，那么这个括号运算得到的，就是这个表达式的值。表达式的值，在 ECMAScript 的规范中，称为“引用”。我们再来看看<code>delete 0</code>。  </p><pre><code class="hljs javascript"><span class="hljs-keyword">delete</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 0 视为一个表达式，并尝试删除它的求值结果。</span><span class="hljs-comment">// 0不是值（Value）类型的数据，而是一个表达式运算的结果值（Result）。而在进一步的删除操作之前，JavaScript 需要检测这个 Result 的类型：</span><span class="hljs-comment">// 如果它是值，则按照传统的 JavaScript 的约定返回 true；</span><span class="hljs-comment">// 如果它是一个引用，那么对该引用进行分析，以决定如何操作。</span></code></pre><p> 再举个栗子<br> <pre><code class="hljs javascript">x = x; <span class="hljs-comment">//在表达什么？</span><span class="hljs-comment">// 引用 x 赋值给引用 x</span><span class="hljs-comment">// x 放在左边作为 lhs，那么它是引用；如果放在右边作为 rhs，那么对x进行求值x = GetValue(x)</span></code></pre></p><h3 id="引用类型的构成"><a href="#引用类型的构成" class="headerlink" title="引用类型的构成"></a>引用类型的构成</h3><p>　　一个引用是个<strong>已解析的命名绑定</strong>(a resolved name or property binding,也就是标示符和属性访问会创建引用)，由三部分组成：基值、引用名称和一个严格引用标志（布尔值）。 基值是 undefined、Object、Boolean、String、Number、环境记录项中的任意一个。基值是 undefined 表示此引用不可以解析为一个绑定。引用名称是一个字符串。<a href="https://www.w3.org/html/ig/zh/wiki/ES5/%E7%B1%BB%E5%9E%8B#.E5.BC.95.E7.94.A8.E8.A7.84.E8.8C.83.E7.B1.BB.E5.9E.8B" target="_blank" rel="noopener">规范文档</a><br> <pre><code class="hljs javascript"><span class="hljs-comment">// 规范定义了以下抽象操作函数</span>GetBase(V)：返回引用值 V 的基值部分。GetValue(V):...HasPrimitiveBase(V)：如果基值是 <span class="hljs-built_in">Boolean</span>、<span class="hljs-built_in">String</span>、<span class="hljs-built_in">Number</span>，那么返回 <span class="hljs-literal">true</span>。IsPropertyReference(V)：如果基值是个 <span class="hljs-built_in">Object</span> 或 HasPrimitiveBase(V) 是 <span class="hljs-literal">true</span>，那么返回 <span class="hljs-literal">true</span>；否则返回 <span class="hljs-literal">false</span>。</code></pre></p>]]></content>
    
    
    
    <tags>
      
      <tag>前端知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重学 JS 高级程序设计</title>
    <link href="/2020/09/30/%E9%87%8D%E5%AD%A6-JS-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/09/30/%E9%87%8D%E5%AD%A6-JS-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>　　最近新出了《高级程序设计》第四版，和第三版差别还是挺大的。第三版还是大学刚毕业那会买的，没怎么看，因为毕业后一直再写<code>Vue</code>相关的东西，看了在工作中也用不上而遗忘。只是这一年，加入了极验，写原生 JS ，才有点感觉。因为要兼容IE，在浏览器兼容方面导致的 BOM，DOM，事件，网络请求上的区别，所以要求能力检测和客户端检测方面就要做得比较好。在客户端追踪利用到的客户端存储能力，在性能上利用到的<code>Worker</code>。在重新回顾这本书的时候，发现这边书上其实都有介绍。以此记录一些点。完了感觉<code>html</code>似乎没有那么简单。<code>DTD</code>会影响书写文档（html -&gt; xhtml）的格式。HTML5 不基于 SGML，所以不需要引用 DTD。命名空间的设计，避免以后多种类型使用同一个标签的尴尬问题（我目前好像不支持有啥标签冲突的）。</p><ol><li>sri 安全</li><li>catch with 会创建新的环境对象</li><li>typeOf 操作一个没有定义的变量会返回 undefined</li><li>标记清除和引用清除垃圾回收机制</li><li>V8引擎 隐藏共用类</li><li>document.domain 属性限制及通信</li><li>namedItem 通过name 获取节点引用</li><li>document对象上还暴露了几个特殊集合 document.anchors document.forms document.images document.links</li><li>元素是HTMLHtmlElement的实例</li><li>createDocumentFragment 支持不太好</li><li>xml命名空间</li><li>event对象 relatedTarget 属性  IE fromElement toElement</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>前端知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>长工的锄头</title>
    <link href="/2020/08/09/%E9%95%BF%E5%B7%A5%E7%9A%84%E9%94%84%E5%A4%B4/"/>
    <url>/2020/08/09/%E9%95%BF%E5%B7%A5%E7%9A%84%E9%94%84%E5%A4%B4/</url>
    
    <content type="html"><![CDATA[<p>　　最近公司优化了一拨人，其中不乏有能力不错的，还有一个在公司呆了5年的。我想我没有被优化的原因完全是因为目前负责的项目线忙不过来。有活干。<br>　　突然觉得技术不是唯一在职场的竞争力了，或许一直都不是，只是我自己幼稚得觉得。<br>　　要想清楚以后做什么了。<br>　　长工就是长工，锄头锋利点又有啥用，关键还是看替老板挖什么。<br>　　如果能有一天，自己也尝试雇佣两个长工吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是 BFC</title>
    <link href="/2020/07/01/%E4%BB%80%E4%B9%88%E6%98%AF-BFC/"/>
    <url>/2020/07/01/%E4%BB%80%E4%B9%88%E6%98%AF-BFC/</url>
    
    <content type="html"><![CDATA[<p>　　查了半天资料，<code>BFC</code>似乎是<code>CSS</code>独有的概念，在其他领域没有这种概念。再理解<code>BFC</code>之前，我们先看看<code>CSS</code>是怎么工作的。</p><h3 id="css2-1-处理模型"><a href="#css2-1-处理模型" class="headerlink" title="css2.1 处理模型"></a>css2.1 处理模型</h3><p>　　在<a href="https://www.w3.org/TR/2011/REC-CSS2-20110607/intro.html#q2.0" target="_blank" rel="noopener">css2.1规范文档</a>里有提到一种用户代理处理<code>CSS</code>代码的工作模型。</p><ol><li>解析源文档并创建文档树.</li><li>识别目标媒体类型.（media）</li><li>检索文档相关特定目标媒体类型的所有样式表</li><li>通过给每个适用于目标媒体类型的属性赋值来为文档树中的元素做标注。根据层叠与继承中描述的机制来对属性赋值<br>值的计算部分取决于适用于目标媒体类型的格式化算法。例如，如果目标媒体是screen，用户代理会应用<strong>视觉格式化模型</strong></li><li>根据有标注的文档树，生成格式化结构。（DOM + CSSOM）</li><li>把格式化结构传递给目标媒体（例如，打印结果，在屏幕上显示，渲染为声音等等）  </li></ol><h3 id="视觉格式化模型"><a href="#视觉格式化模型" class="headerlink" title="视觉格式化模型"></a>视觉格式化模型</h3><p>　　视觉格式化模型的作用是对于可视化媒体，用户代理怎样处理文档树（也就是浏览器）。在视觉格式化模型中，文档树中的每个元素根据其盒模型生成0个或多个盒。这些盒的布局由（以下因素）控制：  </p><ol><li>盒尺寸与类型</li><li>定位方案（<strong>常规流</strong>，浮动与绝对定位）</li><li>文档树中元素间的关系</li><li>外部信息（例如，视口大小，图片的固有尺寸等等  </li></ol><h3 id="定位方案"><a href="#定位方案" class="headerlink" title="定位方案"></a>定位方案</h3><p>　　CSS 2.1中，一个盒可能会根据三种定位方案来布局：</p><ol><li>常规流 CSS 2.1中，常规流包括块级盒的块格式化（block formatting），行内级盒的行内格式化和块级与行内级盒的相对定位</li><li>浮动 在浮动模型中，盒先根据常规流来放置，然后从常规流中取出来并尽可能远地向左或向右移动。其它内容可能沿着浮动（盒）的一侧排列（Content may flow along the side of a float）</li><li>绝对定位 在绝对定位模型中，一个盒会从常规流中全部移除（它不会影响后面的兄弟元素）并根据包含块确定位置  </li></ol><h3 id="常规流"><a href="#常规流" class="headerlink" title="常规流"></a>常规流</h3><p>　　常规流中的盒属于一个格式化上下文，可能是块或是行内（格式化上下文），但不能两者都是。块级盒参与块格式化上下文。行内级盒参与行内格式化上下文</p><h3 id="块格式化上下文"><a href="#块格式化上下文" class="headerlink" title="块格式化上下文"></a>块格式化上下文</h3><p>　　块级格式化化上下文也就是我们说的<code>BFC</code>。<br>　　浮动，绝对定位的元素，非块盒的块容器（例如inline-blocks，table-cells和table-captions），以及’overflow’不为’visible’的块盒。会为其内容建立新的块格式化上下文。</p><h3 id="块格式化上下文的特点"><a href="#块格式化上下文的特点" class="headerlink" title="块格式化上下文的特点"></a>块格式化上下文的特点</h3><p>　　在一个块格式化上下文中，盒在垂直方向一个接一个地放置，从包含块的顶部开始。两个兄弟盒之间的垂直距离由’margin’属性决定。同一个块格式化上下文中的相邻块级盒之间的垂直外边距会合并。<br>　　在一个块格式化上下文中，每个盒的左外边界（left outer edge）挨着包含块的左外边界（对于从右向左的格式化，右外边界挨着）。即使存在浮动，这也成立。除非该盒建立了一个新的块格式化上下文（这种情况下，该盒自身可能会因为浮动变窄）。</p><h3 id="什么是-BFC"><a href="#什么是-BFC" class="headerlink" title="什么是 BFC"></a>什么是 BFC</h3><p>　　浏览器在渲染的时候，按照一定的规则（css规范）来处理。<code>BFC</code>就是其中一种。仅此而已。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端知识</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue源码解析 keep-alive</title>
    <link href="/2020/06/29/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-keep-alive/"/>
    <url>/2020/06/29/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-keep-alive/</url>
    
    <content type="html"><![CDATA[<p>　　<code>keep-alive</code>组件应用场景就是为了组件的缓存优化。  </p><h3 id="全局组件注册"><a href="#全局组件注册" class="headerlink" title="全局组件注册"></a>全局组件注册</h3><p>　　<code>keep-alive</code>属于平台通用组件，所以在<code>core</code>目录下。在<code>initGlobalAPI</code>时候，会在当前<code>Vue</code>实例上的<code>components</code>属性里扩展。</p><pre><code class="hljs javascript">extend(Vue.options.components, builtInComponents)</code></pre><h3 id="keep-alive组件"><a href="#keep-alive组件" class="headerlink" title="keep-alive组件"></a>keep-alive组件</h3><p>　　和<code>transition</code>组件一样，是一个抽象组件，抽象组件在建立父子关系的时候会被忽略掉。</p><pre><code class="hljs javascript"><span class="hljs-comment">// lifecycleMixin</span><span class="hljs-keyword">let</span> parent = options.parent<span class="hljs-keyword">if</span> (parent &amp;&amp; !options.abstract) &#123;  <span class="hljs-keyword">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;    parent = parent.$parent  &#125;  parent.$children.push(vm)&#125;vm.$parent = parent</code></pre><p>　　我们再看看源码。</p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  name: <span class="hljs-string">"keep-alive"</span>,  ...   created() &#123;    <span class="hljs-comment">// 初始化用于存储缓存的 cache 对象</span>    <span class="hljs-keyword">this</span>.cache = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);    <span class="hljs-comment">// 初始化用于存储VNode key值的 keys 数组</span>    <span class="hljs-keyword">this</span>.keys = [];  &#125;,  ...  render() &#123;    <span class="hljs-comment">// 获取第一个子元素的 vnode</span>    <span class="hljs-keyword">const</span> slot = <span class="hljs-keyword">this</span>.$slots.default;    <span class="hljs-keyword">const</span> vnode: VNode = getFirstComponentChild(slot);    <span class="hljs-keyword">const</span> componentOptions: ?VNodeComponentOptions =      vnode &amp;&amp; vnode.componentOptions;    <span class="hljs-keyword">if</span> (componentOptions) &#123;      <span class="hljs-comment">// 从inlcude和exlude中匹配name</span>      <span class="hljs-keyword">const</span> name: ?string = getComponentName(componentOptions);      <span class="hljs-keyword">const</span> &#123; include, exclude &#125; = <span class="hljs-keyword">this</span>;      <span class="hljs-keyword">if</span> (        (include &amp;&amp; (!name || !matches(include, name))) ||        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))      ) &#123;        <span class="hljs-keyword">return</span> vnode;      &#125;      <span class="hljs-keyword">const</span> &#123; cache, keys &#125; = <span class="hljs-keyword">this</span>;      <span class="hljs-comment">// 获取key</span>        vnode.key == <span class="hljs-literal">null</span>          ? <span class="hljs-comment">// same constructor may get registered as</span>            <span class="hljs-comment">// different local components</span>            <span class="hljs-comment">// so cid alone is not enough (#3269)</span>            componentOptions.Ctor.cid +            (componentOptions.tag ? <span class="hljs-string">`::<span class="hljs-subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="hljs-string">""</span>)          : vnode.key;      <span class="hljs-comment">// 如果命中缓存，直接从缓存中拿，然后调整key的顺序</span>      <span class="hljs-keyword">if</span> (cache[key]) &#123;        vnode.componentInstance = cache[key].componentInstance;        <span class="hljs-comment">// make current key freshest</span>        remove(keys, key);        keys.push(key);      &#125;      <span class="hljs-comment">// 如果没有命中缓存,就把 vnode 放进缓存</span>      <span class="hljs-keyword">else</span> &#123;        cache[key] = vnode;        keys.push(key);        <span class="hljs-comment">// 如果配置了 max 并且缓存的长度超过了 this.max，还要从缓存中最近没有访问的那个，也就是第一个。</span>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.max &amp;&amp; keys.length &gt; <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">this</span>.max)) &#123;          pruneCacheEntry(cache, keys[<span class="hljs-number">0</span>], keys, <span class="hljs-keyword">this</span>._vnode);        &#125;      &#125;            <span class="hljs-comment">// keepAlive标记位</span>      vnode.data.keepAlive = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-comment">// 返回当前Vnode</span>    <span class="hljs-keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="hljs-number">0</span>]);  &#125;&#125;;</code></pre><h3 id="LRU缓存算法"><a href="#LRU缓存算法" class="headerlink" title="LRU缓存算法"></a>LRU缓存算法</h3><p>　　常见的缓存算法有几种，<code>LRU</code>， <code>LFU</code>，以及<code>FIFO</code>，显然<code>Vue</code>这里使用了<code>LRU</code>,使用了一个<code>Object</code>和一个<code>keys</code>,来分别存储组件vnode和控制访问的<code>keys</code>。当超过了<code>max</code>属性的时候，<code>keep-alive</code>会删除掉最近不怎么访问的那个组件的缓存。<br>　　我们可以自己实现一个<code>LRU</code>算法。因为<code>JS</code>里的<code>Map</code>这种结构可以记住插入顺序，所以我使用了<code>Map</code>。也是<code>leetcode</code>的<a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146题</a></p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">capacity</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">var</span> LRUCache = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">capacity</span>) </span>&#123;  <span class="hljs-keyword">this</span>.maxsize = capacity  <span class="hljs-keyword">this</span>.data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()&#125;;<span class="hljs-comment">/** </span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">key</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span>LRUCache.prototype.get = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.data.has(key)) &#123;    <span class="hljs-comment">// 访问的时候删除旧的，set一个一样的新的</span>    <span class="hljs-keyword">let</span> value = <span class="hljs-keyword">this</span>.data.get(key)    <span class="hljs-keyword">this</span>.data.delete(key)    <span class="hljs-keyword">this</span>.data.set(key, value)    <span class="hljs-keyword">return</span> value  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>  &#125;&#125;;<span class="hljs-comment">/** </span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>key </span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">value</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;void&#125;</span></span></span><span class="hljs-comment"> */</span>LRUCache.prototype.put = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key, value</span>) </span>&#123;  <span class="hljs-comment">// map里有值,直接更新</span>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.data.has(key)) &#123;    <span class="hljs-keyword">this</span>.data.delete(key)    <span class="hljs-keyword">this</span>.data.set(key, value)  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// map里没有值，判断缓存大小</span>    <span class="hljs-comment">// 删除最开始的那个值</span>    <span class="hljs-comment">// 这里每次会生成一个临时的迭代器</span>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.data.size === <span class="hljs-keyword">this</span>.maxsize) &#123;      <span class="hljs-keyword">this</span>.data.delete(<span class="hljs-keyword">this</span>.data.keys().next().value);      <span class="hljs-keyword">this</span>.data.set(key,value)    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">this</span>.data.set(key, value)    &#125;  &#125;&#125;;</code></pre><h3 id="缓存渲染"><a href="#缓存渲染" class="headerlink" title="缓存渲染"></a>缓存渲染</h3><p>　　我们知道，组件一旦被 <code>keep-alive</code> 缓存，那么再次渲染的时候就不会执行 <code>created</code>、<code>mounted</code> 等钩子函数。所以<code>Vue</code>提供了<code>activated</code>和<code>deactivated</code>钩子。<br>　　在<code>patchVnode</code>的时候，我们会执行<code>prepatch</code>钩子，在这里我们会执行<code>updateChildComponent</code>。在<code>updateChildComponent</code>中，有这么一段。  </p><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (hasChildren) &#123;    vm.$slots = resolveSlots(renderChildren, parentVnode.context)    vm.$forceUpdate()  &#125;</code></pre><p>　　前面我们已经分析了，如果命中缓存，则直接返回<code>vnode.componentInstance</code>,然后强制更新。这个时候回再次执行<code>createComponent</code>方法。    </p><pre><code class="hljs javascript"><span class="hljs-comment">// createComponent</span>...<span class="hljs-keyword">const</span> isReactivated = isDef(vnode.componentInstance) &amp;&amp; i.keepAlive <span class="hljs-comment">// true</span><span class="hljs-keyword">const</span> isReactivated = isDef(vnode.componentInstance) &amp;&amp; i.keepAlive    <span class="hljs-keyword">if</span> (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) &#123;      <span class="hljs-comment">// 执行init钩子的时候，如果是keep-alive 则不会执行$mount</span>      <span class="hljs-comment">//   if (</span>      <span class="hljs-comment">//   vnode.componentInstance &amp;&amp;</span>      <span class="hljs-comment">//   !vnode.componentInstance._isDestroyed &amp;&amp;</span>      <span class="hljs-comment">//   vnode.data.keepAlive</span>      <span class="hljs-comment">// ) </span>      i(vnode, <span class="hljs-literal">false</span> <span class="hljs-comment">/* hydrating */</span>)    &#125;...<span class="hljs-keyword">if</span> (isTrue(isReactivated)) &#123;  <span class="hljs-comment">// 会执行reactivateComponent方法</span>  <span class="hljs-comment">// 更新insertedVnodeQueue</span>  reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)&#125;</code></pre><p>　　在渲染的最后一步<code>invokeInsertHook</code>的时候，会执行<code>vnode</code>的<code>insert</code>钩子函数。会根据<code>vnode</code>的<code>keepAlive</code>属性来执行不同的方法</p><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (vnode.data.keepAlive) &#123;      <span class="hljs-keyword">if</span> (context._isMounted) &#123;        <span class="hljs-comment">// vue-router#1212</span>        <span class="hljs-comment">// During updates, a kept-alive component's child components may</span>        <span class="hljs-comment">// change, so directly walking the tree here may call activated hooks</span>        <span class="hljs-comment">// on incorrect children. Instead we push them into a queue which will</span>        <span class="hljs-comment">// be processed after the whole patch process ended.</span>        queueActivatedComponent(componentInstance)        <span class="hljs-comment">//  callHook(vm, 'activated') 在这里触发activated钩子函数</span>      &#125; <span class="hljs-keyword">else</span> &#123;        activateChildComponent(componentInstance, <span class="hljs-literal">true</span> <span class="hljs-comment">/* direct */</span>)      &#125;&#125;</code></pre><p>　　有<code>activated</code>钩子函数，也就有对应的<code>deactivated</code>钩子函数，它是发生在 vnode 的 destory 钩子函数。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> componentVNodeHooks = &#123;  destroy (vnode: MountedComponentVNode) &#123;    <span class="hljs-keyword">const</span> &#123; componentInstance &#125; = vnode    <span class="hljs-keyword">if</span> (!componentInstance._isDestroyed) &#123;      <span class="hljs-keyword">if</span> (!vnode.data.keepAlive) &#123;        componentInstance.$destroy()      &#125; <span class="hljs-keyword">else</span> &#123;        deactivateChildComponent(componentInstance, <span class="hljs-literal">true</span> <span class="hljs-comment">/* direct */</span>)        <span class="hljs-comment">// callHook(vm, 'deactivated') 在这里触发deactivated钩子函数</span>      &#125;    &#125;  &#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>前端知识</tag>
      
      <tag>Vue</tag>
      
      <tag>源码解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue源码解析 transition</title>
    <link href="/2020/06/19/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-transition/"/>
    <url>/2020/06/19/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-transition/</url>
    
    <content type="html"><![CDATA[<p>　　<code>transition</code>组件是<code>Vue</code>内置组件。我们从<code>entry-runtime-with-compiler</code>这个版本的<code>JS</code>进行分析。</p><h3 id="内置组件注册"><a href="#内置组件注册" class="headerlink" title="内置组件注册"></a>内置组件注册</h3><p>　　<code>transition</code>组件是和平台相关的组件（web专属）,所以不在<code>core</code>里面。而是在相关平台<code>JS</code>里引入的。</p><pre><code class="hljs javascript"><span class="hljs-comment">// entry-runtime-with-compiler</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'./runtime/index'</span><span class="hljs-comment">// runtime/index </span><span class="hljs-keyword">import</span> platformComponents <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/index'</span>...<span class="hljs-comment">// 加载平台相关的组件和指令</span>extend(Vue.options.components, platformComponents)</code></pre><h3 id="transition-组件"><a href="#transition-组件" class="headerlink" title="transition 组件"></a>transition 组件</h3><ul><li>我们先来一个示例<code>demo</code>。<pre><code class="hljs javascript"><span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;  el: <span class="hljs-string">'#app'</span>,  template: <span class="hljs-string">'&lt;div id="demo"&gt;'</span> +  <span class="hljs-string">'&lt;button v-on:click="show = !show"&gt;'</span> +  <span class="hljs-string">'Toggle'</span> +  <span class="hljs-string">'&lt;/button&gt;'</span> +  <span class="hljs-string">'&lt;transition :appear="true" name="fade"&gt;'</span> +  <span class="hljs-string">'&lt;p v-if="show"&gt;hello&lt;/p&gt;'</span> +  <span class="hljs-string">'&lt;/transition&gt;'</span> +  <span class="hljs-string">'&lt;/div&gt;'</span>,  data() &#123;    <span class="hljs-keyword">return</span> &#123;      show: <span class="hljs-literal">true</span>    &#125;  &#125;&#125;)</code></pre></li><li>transition render<pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  name: <span class="hljs-string">'transition'</span>,  props: transitionProps,  <span class="hljs-comment">// 抽象组件，和keep-alive一样</span>  abstract: <span class="hljs-literal">true</span>,  render (h: <span class="hljs-built_in">Function</span>) &#123;    <span class="hljs-comment">// 获取包裹的内容</span>    <span class="hljs-keyword">let</span> children: any = <span class="hljs-keyword">this</span>.$slots.default    <span class="hljs-keyword">if</span> (!children) &#123;      <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-comment">// 把文本节点过滤掉</span>    children = children.filter(isNotTextNode)    <span class="hljs-comment">// 如果没有children 直接返回</span>    <span class="hljs-keyword">if</span> (!children.length) &#123;      <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-comment">// transition组件不能包裹多个，多个需要transition-group</span>    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">'production'</span> &amp;&amp; children.length &gt; <span class="hljs-number">1</span>) &#123;      warn(        <span class="hljs-string">'&lt;transition&gt; can only be used on a single element. Use '</span> +        <span class="hljs-string">'&lt;transition-group&gt; for lists.'</span>,        <span class="hljs-keyword">this</span>.$parent      )    &#125;    <span class="hljs-comment">// 获取传入的 props mode</span>    <span class="hljs-keyword">const</span> mode: string = <span class="hljs-keyword">this</span>.mode    <span class="hljs-comment">// warn invalid mode</span>    <span class="hljs-comment">// mode只能选择in-out 和 out-in</span>    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">'production'</span> &amp;&amp;      mode &amp;&amp; mode !== <span class="hljs-string">'in-out'</span> &amp;&amp; mode !== <span class="hljs-string">'out-in'</span>    ) &#123;      warn(        <span class="hljs-string">'invalid &lt;transition&gt; mode: '</span> + mode,        <span class="hljs-keyword">this</span>.$parent      )    &#125;    <span class="hljs-comment">// 第一个子节点</span>    <span class="hljs-keyword">const</span> rawChild: VNode = children[<span class="hljs-number">0</span>]    <span class="hljs-comment">// 如果 是根节点 或者父组件也是一个transition 则直接返回</span>    <span class="hljs-keyword">if</span> (hasParentTransition(<span class="hljs-keyword">this</span>.$vnode)) &#123;      <span class="hljs-keyword">return</span> rawChild    &#125;    <span class="hljs-comment">// 如果包裹的是keepalive 则会递归查找真实的节点,在这个demo里就是 p这个 vnode</span>    <span class="hljs-keyword">const</span> child: ?VNode = getRealChild(rawChild)    <span class="hljs-comment">// 没有则返回当前节点</span>    <span class="hljs-keyword">if</span> (!child) &#123;      <span class="hljs-keyword">return</span> rawChild    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._leaving) &#123;      <span class="hljs-keyword">return</span> placeholder(h, rawChild)    &#125;    <span class="hljs-comment">// 根据不同的情况生成一个 key</span>    <span class="hljs-keyword">const</span> id: string = <span class="hljs-string">`__transition-<span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>._uid&#125;</span>-`</span>    child.key = child.key == <span class="hljs-literal">null</span>      ? child.isComment        ? id + <span class="hljs-string">'comment'</span>        : id + child.tag      : isPrimitive(child.key)        ? (<span class="hljs-built_in">String</span>(child.key).indexOf(id) === <span class="hljs-number">0</span> ? child.key : id + child.key)        : child.ke    <span class="hljs-comment">// render函数其实就做了这么一件事情，把transition的props 和 函数钩子 扩展到当前 data里的 transition属性里。</span>    <span class="hljs-keyword">const</span> data: <span class="hljs-built_in">Object</span> = (child.data || (child.data = &#123;&#125;)).transition = extractTransitionData(<span class="hljs-keyword">this</span>)    <span class="hljs-keyword">const</span> oldRawChild: VNode = <span class="hljs-keyword">this</span>._vnode    <span class="hljs-keyword">const</span> oldChild: VNode = getRealChild(oldRawChild)    ...    <span class="hljs-keyword">return</span> rawChild  &#125;&#125;</code></pre><h3 id="实际控制动画的地方"><a href="#实际控制动画的地方" class="headerlink" title="实际控制动画的地方"></a>实际控制动画的地方</h3>　　<code>Vue</code>会根据不同的入口，挂载不同的<code>pacth</code>。<pre><code class="hljs javascript"><span class="hljs-comment">// runtime/index.js</span>Vue.prototype.__patch__ = inBrowser ? patch : noop</code></pre>　　而<code>patch</code>会根据平台的不同，加载不同的<code>platformModules</code>。而我们的<code>transition</code>就属于其中的一个模块。<pre><code class="hljs javascript"><span class="hljs-comment">// runtime/patch.js</span><span class="hljs-keyword">import</span> platformModules <span class="hljs-keyword">from</span> <span class="hljs-string">'web/runtime/modules/index'</span><span class="hljs-keyword">const</span> modules = platformModules.concat(baseModules)<span class="hljs-comment">// runtime/modules/transition.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> inBrowser ? &#123;  <span class="hljs-comment">// create hook的时候 会执行 _enter</span>  create: _enter,  activate: _enter,  remove (vnode: VNode, <span class="hljs-attr">rm</span>: <span class="hljs-built_in">Function</span>) &#123;    <span class="hljs-comment">/* istanbul ignore else */</span>    <span class="hljs-keyword">if</span> (vnode.data.show !== <span class="hljs-literal">true</span>) &#123;      leave(vnode, rm)    &#125; <span class="hljs-keyword">else</span> &#123;      rm()    &#125;  &#125;&#125; : &#123;&#125;</code></pre>　　然后会合并hooks。<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hooks = [<span class="hljs-string">'create'</span>, <span class="hljs-string">'activate'</span>, <span class="hljs-string">'update'</span>, <span class="hljs-string">'remove'</span>, <span class="hljs-string">'destroy'</span>]...<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; hooks.length; ++i) &#123;    cbs[hooks[i]] = []    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; modules.length; ++j) &#123;      <span class="hljs-keyword">if</span> (isDef(modules[j][hooks[i]])) &#123;        cbs[hooks[i]].push(modules[j][hooks[i]])      &#125;    &#125;  &#125;</code></pre>　　也就是说，在<code>web</code>端，执行<code>create</code>钩子函数的时候，实际上会走<code>_enter函数</code>。<pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enter</span> (<span class="hljs-params">vnode: VNodeWithData, toggleDisplay: ?(</span>) =&gt; <span class="hljs-title">void</span>) </span>&#123;  <span class="hljs-comment">// 拿到DOM对象</span>  <span class="hljs-keyword">const</span> el: any = vnode.elm  <span class="hljs-keyword">if</span> (isDef(el._leaveCb)) &#123;    el._leaveCb.cancelled = <span class="hljs-literal">true</span>    el._leaveCb()  &#125;  <span class="hljs-comment">// 自定义动画名字</span>  <span class="hljs-keyword">const</span> data = resolveTransition(vnode.data.transition)  ...  <span class="hljs-comment">// 拿到data上的各种配置</span>  <span class="hljs-keyword">const</span> &#123;    css,    type,   ...  &#125; = data  ...  <span class="hljs-comment">// 获取appear参数</span>  <span class="hljs-keyword">const</span> isAppear = !context._isMounted || !vnode.isRootInsert  <span class="hljs-keyword">if</span> (isAppear &amp;&amp; !appear &amp;&amp; appear !== <span class="hljs-string">''</span>) &#123;    <span class="hljs-keyword">return</span>  &#125;  <span class="hljs-comment">// 接下来就是各种根据配置参数定义Class</span>  <span class="hljs-keyword">const</span> startClass = isAppear &amp;&amp; appearClass    ? appearClass    : enterClass  <span class="hljs-keyword">const</span> activeClass = isAppear &amp;&amp; appearActiveClass    ? appearActiveClass    : enterActiveClass  <span class="hljs-keyword">const</span> toClass = isAppear &amp;&amp; appearToClass    ? appearToClass    : enterToClass    <span class="hljs-comment">// 拿到自定义的钩子</span>  <span class="hljs-keyword">const</span> beforeEnterHook = isAppear    ? (beforeAppear || beforeEnter)    : beforeEnter  <span class="hljs-keyword">const</span> enterHook = isAppear    ? (<span class="hljs-keyword">typeof</span> appear === <span class="hljs-string">'function'</span> ? appear : enter)    : enter  <span class="hljs-keyword">const</span> afterEnterHook = isAppear    ? (afterAppear || afterEnter)    : afterEnter  <span class="hljs-keyword">const</span> enterCancelledHook = isAppear    ? (appearCancelled || enterCancelled)    : enterCancelled    <span class="hljs-comment">// 自定义动画时长</span>  <span class="hljs-keyword">const</span> explicitEnterDuration: any = toNumber(    isObject(duration)      ? duration.enter      : duration  )  ...  <span class="hljs-keyword">const</span> expectsCSS = css !== <span class="hljs-literal">false</span> &amp;&amp; !isIE9  <span class="hljs-comment">// 组件设计用户自己控制动画结束API</span>  <span class="hljs-keyword">const</span> userWantsControl = getHookArgumentsLength(enterHook)  <span class="hljs-comment">// cb函数，会在后面insert的时候掉用</span>  <span class="hljs-keyword">const</span> cb = el._enterCb = once(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (expectsCSS) &#123;      removeTransitionClass(el, toClass)      removeTransitionClass(el, activeClass)    &#125;    <span class="hljs-keyword">if</span> (cb.cancelled) &#123;      <span class="hljs-keyword">if</span> (expectsCSS) &#123;        removeTransitionClass(el, startClass)      &#125;      enterCancelledHook &amp;&amp; enterCancelledHook(el)    &#125; <span class="hljs-keyword">else</span> &#123;      afterEnterHook &amp;&amp; afterEnterHook(el)    &#125;    el._enterCb = <span class="hljs-literal">null</span>  &#125;)  <span class="hljs-keyword">if</span> (!vnode.data.show) &#123;    <span class="hljs-comment">// 插入钩子函数insert</span>    mergeVNodeHook(vnode, <span class="hljs-string">'insert'</span>, () =&gt; &#123;      <span class="hljs-keyword">const</span> parent = el.parentNode      <span class="hljs-keyword">const</span> pendingNode = parent &amp;&amp; parent._pending &amp;&amp; parent._pending[vnode.key]      <span class="hljs-keyword">if</span> (pendingNode &amp;&amp;        pendingNode.tag === vnode.tag &amp;&amp;        pendingNode.elm._leaveCb      ) &#123;        pendingNode.elm._leaveCb()      &#125;      enterHook &amp;&amp; enterHook(el, cb)    &#125;)  &#125;  <span class="hljs-comment">// 开始和进入的动画控制</span>  beforeEnterHook &amp;&amp; beforeEnterHook(el)  <span class="hljs-keyword">if</span> (expectsCSS) &#123;    addTransitionClass(el, startClass)    addTransitionClass(el, activeClass)    nextFrame(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      removeTransitionClass(el, startClass)      <span class="hljs-keyword">if</span> (!cb.cancelled) &#123;        addTransitionClass(el, toClass)        <span class="hljs-keyword">if</span> (!userWantsControl) &#123;          <span class="hljs-keyword">if</span> (isValidDuration(explicitEnterDuration)) &#123;            setTimeout(cb, explicitEnterDuration)          &#125; <span class="hljs-keyword">else</span> &#123;            whenTransitionEnds(el, type, cb)          &#125;        &#125;      &#125;    &#125;)  &#125;</code></pre></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　<code>leave</code>过程和<code>enter</code>其实是一样的，所以真正执行动画的是我们写的 CSS 或者是 JavaScript 钩子函数，而 Vue 的 <transition> 只是帮我们很好地管理了这些 CSS 的添加/删除，以及钩子函数的执行时机。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端知识</tag>
      
      <tag>Vue</tag>
      
      <tag>源码解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器事件循环及消息队列</title>
    <link href="/2020/06/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%8F%8A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/2020/06/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%8F%8A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>　　事件循环的概念早就有了，只能感慨自己见识少。自己的思考方式还是偏向上层应用，还是得多看看软件设计基础。<br>　　事件循环系统由宿主提供，在浏览器里，参照<a href="https://html.spec.whatwg.org/#event-loops" target="_blank" rel="noopener">whatwg</a>。  </p><h3 id="什么是事件循环以及事件循环解决了什么问题"><a href="#什么是事件循环以及事件循环解决了什么问题" class="headerlink" title="什么是事件循环以及事件循环解决了什么问题"></a>什么是事件循环以及事件循环解决了什么问题</h3><p>　　按照规范来说，就是协调用户操作，脚本，渲染，网络等等事件的处理的机制。一个事件循环系统可以有一个或者多个任务队列。<br>　　浏览器从早期的单进程架构走向现在的多进程架构(多进程之间进程隔离，虽然占有空间变大，但是安全性和稳定性会变高)。我们打开一个 <code>chrome</code>的任务管理器。会发现一个<code>tab</code>页下，有多个进程在同时运行。包含浏览器进程、GPU进程、网络进程，音频进程、渲染进程（有些机制会复用同一个渲染进程）、插件进程等等。<br>　　就我们浏览一个网页而言，我们输入一个<code>uri</code>，渲染进程就会通知网络进程去下载资源。下载完毕之后就需要通知渲染进程进行渲染。而浏览器又是进程隔离的。只有渲染进程一个单进程在处理任务，这个时候就需要有一种机制来处理这种情况。也就是消息队列和事件循环。</p><h3 id="消息队列及使用消息队列的缺点"><a href="#消息队列及使用消息队列的缺点" class="headerlink" title="消息队列及使用消息队列的缺点"></a>消息队列及使用消息队列的缺点</h3><p>　　当浏览器遇到对应的输入，不同的进程会向自己的消息队列推送对应的任务。也会通过进程通信，向主线程的消息队<code>postTask</code>。<code>chrome</code>源码中，为不同的任务定义了不同的类型。</p><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskType</span> :</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> &#123;  kJavascriptTimer = <span class="hljs-number">10</span>&#125;</code></pre><p>　　页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。于是，有些任务的实效性就成了问题。</p><h3 id="微任务队列"><a href="#微任务队列" class="headerlink" title="微任务队列"></a>微任务队列</h3><p>　　为了解决实效性的问题，<code>V8</code>设计了微任务队列。在宏任务执行完成之后，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的产生的微任务队列。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端知识</tag>
      
      <tag>浏览器工作原理</tag>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP协议缓存|生鲜速递</title>
    <link href="/2020/06/12/HTTP%E5%8D%8F%E8%AE%AE%E7%BC%93%E5%AD%98%7C%E7%94%9F%E9%B2%9C%E9%80%9F%E9%80%92/"/>
    <url>/2020/06/12/HTTP%E5%8D%8F%E8%AE%AE%E7%BC%93%E5%AD%98%7C%E7%94%9F%E9%B2%9C%E9%80%9F%E9%80%92/</url>
    
    <content type="html"><![CDATA[<p>　　<code>HTTP1.1协议</code>加入了缓存控制。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>　　缓存是一种有效的缓解服务器端压力，提升性能的手段。HTTP定义了三种控制缓存的基本机制：新鲜度(Freshness)，验证(Validation)和失效(Expiration)。</p><h3 id="不同种类的缓存"><a href="#不同种类的缓存" class="headerlink" title="不同种类的缓存"></a>不同种类的缓存</h3><p>　　缓存的种类有很多,其大致可归为两类：私有与共享缓存。私有缓存只能作用单独的用户，比如浏览器。而共享缓存可以被多个用户使用。比如代理缓存，CDN,反向代理，负载均衡等。</p><h3 id="生鲜速递"><a href="#生鲜速递" class="headerlink" title="生鲜速递"></a>生鲜速递</h3><p>　　我们用一个生鲜速递的例子来描述缓存。<br>　　夏天到了，我们打开冰箱，想找瓶快乐水。但是发现没有，于是我们天猫超市一波，天猫超市给我们送来了一箱快乐水。于是，冰箱成了缓存，我成了浏览器，天猫超市成了服务器，汽水就是资源。<br><img src="/imges/%E8%B6%85%E5%B8%82.png" srcset="/img/loading.gif" alt=""><br>　　我们都知道，有的商品是有保质期的（新鲜度），或者是商家自己打包的商品，你需要询问商家是不是最新的。保质期过了（失效），你可能会把它丢掉，或者你舍不得丢，想继续吃，于是问下商家，还可以吃吗？（验证）。又或者有些东西开袋即食，是不可以保存的。你可以发现， <code>HTTP协议</code>，里的<code>Cache-Control</code>都可以找到对应的字段来处理这些问题。<br>　　<code>max-age</code>对应着保质期。<code>no_store</code>对应着开袋即食，<code>no_cache</code>代表着你使用商品前需要询问下商家。<code>must-revalidate</code>对应着商品过期后，必须询问商家。<code>max-stale</code>对应着商家允许你在过期时间后继续消费商品。</p><h3 id="Cache-Control的缺陷以及解决方案"><a href="#Cache-Control的缺陷以及解决方案" class="headerlink" title="Cache-Control的缺陷以及解决方案"></a>Cache-Control的缺陷以及解决方案</h3><p>　　浏览器用“Cache-Control”做缓存控制只能是刷新数据，不能很好地利用缓存数据，又因为缓存会失效，使用前还必须要去服务器验证是否是最新版。于是你必须发送两个请求。先发送一个<code>HEAD</code>请求，如果过期了，再发送一个<code>GET</code>请求。  </p><p>　　针对这种情况,<code>HTTP协议</code>加入了条件请求，让服务也有了控制缓存的权限。当客户端发起一个请求时，缓存检索到已有一个对应的陈旧资源（缓存副本），则缓存会先将此请求附加一个<code>If-None-Match</code>头，然后发给目标服务器，以此来检查该资源副本是否是依然还是算新鲜的，若服务器返回了 304 (Not Modified)（该响应不会有带有实体信息），则表示此资源副本是新鲜的，这样一来，可以节省一些带宽。若服务器通过 <code>If-None-Match</code> 或 <code>If-Modified-Since</code>判断后发现已过期，那么会带有该资源的实体内容返回。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端知识</tag>
      
      <tag>浏览器工作原理</tag>
      
      <tag>HTTP 协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符集 和 JavaScript</title>
    <link href="/2020/06/11/%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8CJavaScript/"/>
    <url>/2020/06/11/%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8CJavaScript/</url>
    
    <content type="html"><![CDATA[<p>　　JavaScript源代码文本支持所有的 <code>Unicode</code> 字符集。在 <code>ECMA262 10th</code>上，定义的是 <code>U+0000 to U+10FFFF</code> 区间。在此记录下了解 <code>Unicode</code>  的过程。  </p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>　　<code>Unicode</code> 的出现，是想让全世界统一一套字符集（不过最近疯狂在弄Emoji），当时在做同样事情的组织还有 <code>UCS</code> 团队。<code>Unicode</code> 为每一个字符规定了 <code>code point</code>,也就是码点。它从0开始，为每个符号指定一个编号。使用 <code>U+</code> 跟在后面的十六进制数来表示。<code>U+597D</code>，JavaScript允许直接用码点表示Unicode字符，比如 <code>\u597D</code>。<code>Unicode</code> 按区间来划分。最前面的65536个字符位，称为BMP，写成16进制就是从<code>U+0000</code>到<code>U+FFFF</code>。所有最常见的字符都放在这个平面。在<code>JS</code>中也最好只使用这些字符。</p><h3 id="UTF-8与UTF-16，UTF-32"><a href="#UTF-8与UTF-16，UTF-32" class="headerlink" title="UTF-8与UTF-16，UTF-32"></a>UTF-8与UTF-16，UTF-32</h3><p>　　<code>Unicode</code>只是规定了码点，但是并没有规定具体的编码形式。也就是说，最直观的就是 <code>UTF-32</code>,每个码点使用四个字节表示，字节内容一一对应码点。比如字母<code>A</code> 就是 <code>\u0041</code>。在内存中就是<code>0x00000041</code>。虽然这种方式查找效率高，但是对于大部分小于<code>U+FFFF</code>的字节来说，文件会大4倍。于是 <code>utf-8</code> 和 <code>utf-16</code> 这种可变长度就受到了大家亲睐。  </p><ul><li>utf-8<br>　　UTF-8是一种变长的编码方法，字符长度从1个字节到4个字节不等。UTF-8 的编码规则很简单，只有二条：  </li></ul><ol><li><p>对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。  </p></li><li><p>对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。  </p></li></ol><ul><li><p>utf-16<br>utf-16编码应该是最优秀了的，因为同时结合了定长和变长两种编码方法的特点。它的编码规很简单：基本平面的字符占用2个字节，辅助平面的字符占用4个字节。所以很好的平衡了时间和空间。  </p><h3 id="字符集和-JavaScript"><a href="#字符集和-JavaScript" class="headerlink" title="字符集和 JavaScript"></a>字符集和 JavaScript</h3><p>　　早期的<code>JS</code>是采用的<code>UCS-2</code>编码，使用2个字节表示已经有码点的字符。所以随着 <code>Unicode</code>的发展，2个字节已经不足以表达所有的码点。导致<code>JavaScript</code>的字符函数都受到了影响，无法返回正确结果。  </p><pre><code class="javascript"><span class="keyword">let</span> s = <span class="string">'𝄆'</span>s.length <span class="comment">// 2</span></code></pre></li></ul><p>　　好在 <code>ES6</code> 字符串对于字符进行了加强。关于超过<code>\uFFFF</code>的码点，可以这样表示<code>\u{1D106}</code>。但是，为了保持兼容，length属性还是原来的行为方式。为了得到字符串的正确长度，可以用下面的方式。<br>　　<code>Array.from(string).length</code>。  </p><p>　　也新增了几个专门处理4字节码点的函数.</p><pre><code class="javascript"><span class="built_in">String</span>.fromCodePoint()：从Unicode码点返回对应字符<span class="built_in">String</span>.prototype.codePointAt()：从字符返回对应的码点<span class="built_in">String</span>.prototype.at()：返回字符串给定位置的字符</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>前端知识</tag>
      
      <tag>计算机基础</tag>
      
      <tag>编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP协议是什么以及不是什么</title>
    <link href="/2020/06/09/HTTP%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%BB%80%E4%B9%88%E4%BB%A5%E5%8F%8A%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2020/06/09/HTTP%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%BB%80%E4%B9%88%E4%BB%A5%E5%8F%8A%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h3 id="HTTP协议是什么？"><a href="#HTTP协议是什么？" class="headerlink" title="HTTP协议是什么？"></a>HTTP协议是什么？</h3><p>　　超文本传输协议。是一个用于传输超媒体文档（例如 HTML）的<strong>应用层</strong>协议。<strong>是纯粹的文本协议</strong>，<strong>可以在任何可靠的传输层上使用</strong>。（ HTTP/2 基于 Google 的 SPDY 协议，HTTP/3 基于 Google 的 QUIC 协议），但是通常是基于 TCP/IP 层，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 如果建立在 TCP 的基础上，那么就遵循Request-Response 的模式。也就是说通讯必定是由用户代理首先发起的。</p><p><img src="/imges/HTTP&layers.png" srcset="/img/loading.gif" alt=""><br>　　HTTP被设计于20世纪90年代初期，在最开始设计的时候，只是用于从服务器获取文档，所以只定义了 <code>GET</code> 操作，在后来的日子里，随着计算机媒体的技术的发展，出现了 <code>JPEG</code>，<code>MP3</code> 音乐等，于是有了 <code>HTTP/1.0</code> 。  </p><p>　　<code>HTTP/1.0</code>形式上已经和现在的 <code>HTTP/1.1</code>差别不大了。  </p><ol><li>增加了 HEAD、POST 等新方法；</li><li>增加了响应状态码，标记可能的错误原因；</li><li>引入了协议版本号概念；</li><li>引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；</li><li><strong>传输的数据</strong>不再仅限于文本（只是传输的数据不仅限于文本）。</li></ol><p>　　但是这个时候<code>HTTP</code>还是社区维护的状态，大家随意修改。浏览器各自有各自的实现方式，直到浏览器大战的95年后，<code>HTTP</code> 才正式有了一份文档, <a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">编号为 RFC 2616</a>。</p><p>　　从版本号我们就可以看到<code>HTTP/1.1</code> 是对 <code>HTTP/1.0</code>的小幅度修正。但是它是一份正式的标准，也就是说，大部分正规的软件会参考标准来做东西（我没有说IE，真的）。  </p><p>　　HTTP/1.1 主要的变更点有：  </p><ol><li>增加了 PUT、DELETE 等新的方法；</li><li>增加了缓存管理和控制；</li><li>明确了连接管理，允许持久连接；</li><li>允许响应数据分块（chunked），利于传输大文件；</li><li>强制要求 Host 头，让互联网主机托管成为可能。</li></ol><p>　　除此之外，<code>HTTP</code> 协议还规定报文必须有 <code>header</code>，但可以没有 <code>body</code>，而且在<code>header</code> 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。如下图所示：<br><img src="/imges/httpmessage.png" srcset="/img/loading.gif" alt=""> </p><p>　　我们可以使用<code>Node</code>来模拟下用户代理已经服务器。</p><ul><li>client端<pre><code class="hljs javascript"><span class="hljs-comment">// client</span><span class="hljs-comment">// 创建一个TCP链接后，使用纯文本传输内容，这就是HTTP协议</span><span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">'net'</span>);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transforHeader</span>(<span class="hljs-params">headers</span>) </span>&#123;    <span class="hljs-keyword">let</span> test = <span class="hljs-built_in">Object</span>.keys(headers).map(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> key + <span class="hljs-string">': '</span> + headers[key]    &#125;).join(<span class="hljs-string">'\r\n'</span>)    <span class="hljs-keyword">return</span> test;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">option, cb1, cb2</span>) </span>&#123;    <span class="hljs-keyword">let</span> client = net.createConnection(&#123;        port: option.port || <span class="hljs-number">8080</span>    &#125;, () =&gt; &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'服务器链接成功'</span>)        client.write(option.method + <span class="hljs-string">' / HTTP/1.1\r\n'</span> + transforHeader(option.headers) + <span class="hljs-string">'\r\n\r\n'</span> + <span class="hljs-string">'123'</span>);    &#125;);    client.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(data)        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(data))        cb1(data.toString())        client.end();    &#125;);    client.on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'断开与服务器的连接'</span>);    &#125;);    client.on(<span class="hljs-string">'error'</span>, (err) =&gt; &#123;        cb2(err)        <span class="hljs-built_in">console</span>.log(err)    &#125;)&#125;request(&#123;<span class="hljs-attr">port</span>:<span class="hljs-number">8080</span>, <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>, <span class="hljs-attr">headers</span>: &#123;<span class="hljs-string">'Host'</span>: <span class="hljs-string">'localhost:8080'</span>,<span class="hljs-string">'Accept'</span>: <span class="hljs-string">'accept-encoding: gzip, deflate, br'</span>,<span class="hljs-string">'content-length'</span>: <span class="hljs-string">'3'</span>&#125;&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cb1</span>(<span class="hljs-params">data</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(data)&#125;,<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cb2</span>(<span class="hljs-params">err</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(err)&#125;)</code></pre></li><li>server端<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>)<span class="hljs-keyword">let</span> httpServer = http.createServer( (req, res) =&gt; &#123;    <span class="hljs-keyword">let</span>  body = <span class="hljs-string">""</span>;    <span class="hljs-built_in">console</span>.log(req.headers)    req.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>) </span>&#123;      body += chunk;    &#125;);    res.writeHead(<span class="hljs-number">200</span>, &#123;<span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/plain'</span>&#125;);    res.write(<span class="hljs-string">"Hello World"</span>);    req.on(<span class="hljs-string">'end'</span>, () =&gt; &#123;       <span class="hljs-built_in">console</span>.log(body)       res.end()    &#125;) &#125;).listen(<span class="hljs-number">8080</span>);</code></pre>　　测试过程中，发现<code>Content-length</code> 是必传的(非chunk模式)，而且需要自己去计算。但是并没有如文档所描述的那样，必须有 <code>host</code> 头. 可能和具体的<code>server</code>实现有关系。</li></ul><h3 id="HTTP协议不是什么？"><a href="#HTTP协议不是什么？" class="headerlink" title="HTTP协议不是什么？"></a>HTTP协议不是什么？</h3><p>  <code>HTTP</code>不是单独的实体，不能单独存在，它基于可靠的传输层协议，也有一些协议基于它。<code>HTTP</code>专门用来在两点之间传输数据，不能用于广播、寻址或路由。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端知识</tag>
      
      <tag>浏览器工作原理</tag>
      
      <tag>HTTP 协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端之外</title>
    <link href="/2019/02/28/%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%A4%96/"/>
    <url>/2019/02/28/%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%A4%96/</url>
    
    <content type="html"><![CDATA[<p>　　最近看到阮一峰老师分享的一篇文章<a href="http://rubyhacker.com/blog2/20150917.html" target="_blank" rel="noopener">失传的计算机科学</a>深有同感，如今越来越标准化的开发方式和工具使得开发越来越容易，你很难想象一个使用<code>Vue-Cli</code>工具的前端开发居然不明白<code>webpack</code>是怎么工作的。更奇怪的是，他们任然能够出色的完成需求。<br>软件的开发成本理应越来越低，软件开发从一个刀耕火种的年代一路走到今天，前辈们总结出来的经验和智慧变成工具，从一开始的拖拖拽拽到现在机器学习，工具已经可以强大到可以替代大部分重复劳动的工种。<br>　　但是问题就在这里，现在的工具还不够成熟。<br>　　你无法忽视网络协议，无法忽视性能，无法忽视安全。<br>　　如果有一天，工具能够解决这些问题了。我们应该感觉到开心，大可不必担心自己被替代。<br>因为，可以转行做产品经理啊。(｡･∀･)ﾉﾞ&quot;</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
