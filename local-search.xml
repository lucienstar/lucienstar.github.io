<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>字符集 和 JavaScript</title>
    <link href="/2020/06/11/%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8CJavaScript/"/>
    <url>/2020/06/11/%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8CJavaScript/</url>
    
    <content type="html"><![CDATA[<p>　　JavaScript源代码文本支持所有的 <code>Unicode</code> 字符集。在 <code>ECMA262 10th</code>上，定义的是 <code>U+0000 to U+10FFFF</code> 区间。在此记录下了解 <code>Unicode</code>  的过程。  </p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>　　<code>Unicode</code> 的出现，是想让全世界统一一套字符集（不过最近疯狂在弄Emoji），当时在做同样事情的组织还有 <code>UCS</code> 团队。<code>Unicode</code> 为每一个字符规定了 <code>code point</code>,也就是码点。它从0开始，为每个符号指定一个编号。使用 <code>U+</code> 跟在后面的十六进制数来表示。<code>U+597D</code>，JavaScript允许直接用码点表示Unicode字符，比如 <code>\u597D</code>。<code>Unicode</code> 按区间来划分。最前面的65536个字符位，称为BMP，写成16进制就是从<code>U+0000</code>到<code>U+FFFF</code>。所有最常见的字符都放在这个平面。在<code>JS</code>中也最好只使用这些字符。</p><h3 id="UTF-8与UTF-16，UTF-32"><a href="#UTF-8与UTF-16，UTF-32" class="headerlink" title="UTF-8与UTF-16，UTF-32"></a>UTF-8与UTF-16，UTF-32</h3><p>　　<code>Unicode</code>只是规定了码点，但是并没有规定具体的编码形式。也就是说，最直观的就是 <code>UTF-32</code>,每个码点使用四个字节表示，字节内容一一对应码点。比如字母<code>A</code> 就是 <code>\u0041</code>。在内存中就是<code>0x00000041</code>。虽然这种方式查找效率高，但是对于大部分小于<code>U+FFFF</code>的字节来说，文件会大4倍。于是 <code>utf-8</code> 和 <code>utf-16</code> 这种可变长度就受到了大家亲睐。  </p><ul><li>utf-8<br>　　UTF-8是一种变长的编码方法，字符长度从1个字节到4个字节不等。UTF-8 的编码规则很简单，只有二条：  </li></ul><ol><li><p>对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。  </p></li><li><p>对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。  </p></li></ol><ul><li><p>utf-16<br>utf-16编码应该是最优秀了的，因为同时结合了定长和变长两种编码方法的特点。它的编码规很简单：基本平面的字符占用2个字节，辅助平面的字符占用4个字节。所以很好的平衡了时间和空间。  </p><h3 id="字符集和-JavaScript"><a href="#字符集和-JavaScript" class="headerlink" title="字符集和 JavaScript"></a>字符集和 JavaScript</h3><p>　　早期的<code>JS</code>是采用的<code>UCS-2</code>编码，使用2个字节表示已经有码点的字符。所以随着 <code>Unicode</code>的发展，2个字节已经不足以表达所有的码点。导致<code>JavaScript</code>的字符函数都受到了影响，无法返回正确结果。  </p><pre><code class="javascript"><span class="keyword">let</span> s = <span class="string">'𝄆'</span>s.length <span class="comment">// 2</span></code></pre></li></ul><p>　　好在 <code>ES6</code> 字符串对于字符进行了加强。关于超过<code>\uFFFF</code>的码点，可以这样表示<code>\u{1D106}</code>。但是，为了保持兼容，length属性还是原来的行为方式。为了得到字符串的正确长度，可以用下面的方式。  </p><pre><code>`Array.from(string).length`。  </code></pre><p>　　也新增了几个专门处理4字节码点的函数。  </p><pre><code>```javascriptString.fromCodePoint()：从Unicode码点返回对应字符String.prototype.codePointAt()：从字符返回对应的码点String.prototype.at()：返回字符串给定位置的字符```  </code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>前端知识</tag>
      
      <tag>计算机基础</tag>
      
      <tag>编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP协议是什么以及不是什么</title>
    <link href="/2020/06/09/HTTP%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%BB%80%E4%B9%88%E4%BB%A5%E5%8F%8A%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2020/06/09/HTTP%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%BB%80%E4%B9%88%E4%BB%A5%E5%8F%8A%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h3 id="HTTP协议是什么？"><a href="#HTTP协议是什么？" class="headerlink" title="HTTP协议是什么？"></a>HTTP协议是什么？</h3><p>　　超文本传输协议。是一个用于传输超媒体文档（例如 HTML）的<strong>应用层</strong>协议。<strong>是纯粹的文本协议</strong>，<strong>可以在任何可靠的传输层上使用</strong>。（ HTTP/2 基于 Google 的 SPDY 协议，HTTP/3 基于 Google 的 QUIC 协议），但是通常是基于 HTTP/IP 层，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 如果建立在 TCP 的基础上，那么就遵循Request-Response 的模式。也就是说通讯必定是由用户代理首先发起的。</p><p><img src="/imges/HTTP&layers.png" srcset="/img/loading.gif" alt=""><br>　　HTTP被设计于20世纪90年代初期，在最开始设计的时候，只是用于从服务器获取文档，所以只定义了 <code>GET</code> 操作，在后来的日子里，随着计算机媒体的技术的发展，出现了 <code>JPEG</code>，<code>MP3</code> 音乐等，于是有了 <code>HTTP/1.0</code> 。  </p><p>　　<code>HTTP/1.0</code>形式上已经和现在的 <code>HTTP/1.1</code>差别不大了。  </p><ol><li>增加了 HEAD、POST 等新方法；</li><li>增加了响应状态码，标记可能的错误原因；</li><li>引入了协议版本号概念；</li><li>引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；</li><li><strong>传输的数据</strong>不再仅限于文本（只是传输的数据不仅限于文本）。</li></ol><p>　　但是这个时候<code>HTTP</code>还是社区维护的状态，大家随意修改。浏览器各自有各自的实现方式，直到浏览器大战的95年后，<code>HTTP</code> 才正式有了一份文档, <a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">编号为 RFC 2616</a>。</p><p>　　从版本号我们就可以看到<code>HTTP/1.1</code> 是对 <code>HTTP/1.0</code>的小幅度修正。但是它是一份正式的标准，也就是说，大部分正规的软件会参考标准来做东西（我没有说IE，真的）。  </p><p>　　HTTP/1.1 主要的变更点有：  </p><ol><li>增加了 PUT、DELETE 等新的方法；</li><li>增加了缓存管理和控制；</li><li>明确了连接管理，允许持久连接；</li><li>允许响应数据分块（chunked），利于传输大文件；</li><li>强制要求 Host 头，让互联网主机托管成为可能。</li></ol><p>　　除此之外，<code>HTTP</code> 协议还规定报文必须有 <code>header</code>，但可以没有 <code>body</code>，而且在<code>header</code> 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。如下图所示：<br><img src="/imges/httpmessage.png" srcset="/img/loading.gif" alt=""> </p><p>　　我们可以使用<code>Node</code>来模拟下用户代理已经服务器。</p><ul><li>client端<pre><code class="hljs javascript"><span class="hljs-comment">// client</span><span class="hljs-comment">// 创建一个TCP链接后，使用纯文本传输内容，这就是HTTP协议</span><span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">'net'</span>);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transforHeader</span>(<span class="hljs-params">headers</span>) </span>&#123;    <span class="hljs-keyword">let</span> test = <span class="hljs-built_in">Object</span>.keys(headers).map(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> key + <span class="hljs-string">': '</span> + headers[key]    &#125;).join(<span class="hljs-string">'\r\n'</span>)    <span class="hljs-keyword">return</span> test;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">option, cb1, cb2</span>) </span>&#123;    <span class="hljs-keyword">let</span> client = net.createConnection(&#123;        port: option.port || <span class="hljs-number">8080</span>    &#125;, () =&gt; &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'服务器链接成功'</span>)        client.write(option.method + <span class="hljs-string">' / HTTP/1.1\r\n'</span> + transforHeader(option.headers) + <span class="hljs-string">'\r\n\r\n'</span> + <span class="hljs-string">'123'</span>);    &#125;);    client.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(data)        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(data))        cb1(data.toString())        client.end();    &#125;);    client.on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'断开与服务器的连接'</span>);    &#125;);    client.on(<span class="hljs-string">'error'</span>, (err) =&gt; &#123;        cb2(err)        <span class="hljs-built_in">console</span>.log(err)    &#125;)&#125;request(&#123;<span class="hljs-attr">port</span>:<span class="hljs-number">8080</span>, <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>, <span class="hljs-attr">headers</span>: &#123;<span class="hljs-string">'Host'</span>: <span class="hljs-string">'localhost:8080'</span>,<span class="hljs-string">'Accept'</span>: <span class="hljs-string">'accept-encoding: gzip, deflate, br'</span>,<span class="hljs-string">'content-length'</span>: <span class="hljs-string">'3'</span>&#125;&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cb1</span>(<span class="hljs-params">data</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(data)&#125;,<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cb2</span>(<span class="hljs-params">err</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(err)&#125;)</code></pre></li><li>server端<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>)<span class="hljs-keyword">let</span> httpServer = http.createServer( (req, res) =&gt; &#123;    <span class="hljs-keyword">let</span>  body = <span class="hljs-string">""</span>;    <span class="hljs-built_in">console</span>.log(req.headers)    req.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>) </span>&#123;      body += chunk;    &#125;);    res.writeHead(<span class="hljs-number">200</span>, &#123;<span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/plain'</span>&#125;);    res.write(<span class="hljs-string">"Hello World"</span>);    req.on(<span class="hljs-string">'end'</span>, () =&gt; &#123;       <span class="hljs-built_in">console</span>.log(body)       res.end()    &#125;) &#125;).listen(<span class="hljs-number">8080</span>);</code></pre>　　测试过程中，发现<code>Content-length</code> 是必传的(非chunk模式)，而且需要自己去计算。但是并没有如文档所描述的那样，必须有 <code>host</code> 头. 可能和具体的<code>server</code>实现有关系。</li></ul><h3 id="HTTP协议不是什么？"><a href="#HTTP协议不是什么？" class="headerlink" title="HTTP协议不是什么？"></a>HTTP协议不是什么？</h3><p>  <code>HTTP</code>不是单独的实体，不能单独存在，它基于可靠的传输层协议，也有一些协议基于它。<code>HTTP</code>专门用来在两点之间传输数据，不能用于广播、寻址或路由。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端知识</tag>
      
      <tag>浏览器工作原理</tag>
      
      <tag>HTTP 协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端之外</title>
    <link href="/2019/02/28/%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%A4%96/"/>
    <url>/2019/02/28/%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%A4%96/</url>
    
    <content type="html"><![CDATA[<p>　　最近看到阮一峰老师分享的一篇文章<a href="http://rubyhacker.com/blog2/20150917.html" target="_blank" rel="noopener">失传的计算机科学</a>深有同感，如今越来越标准化的开发方式和工具使得开发越来越容易，你很难想象一个使用<code>Vue-Cli</code>工具的前端开发居然不明白<code>webpack</code>是怎么工作的。更奇怪的是，他们任然能够出色的完成需求。<br>软件的开发成本理应越来越低，软件开发从一个刀耕火种的年代一路走到今天，前辈们总结出来的经验和智慧变成工具，从一开始的拖拖拽拽到现在机器学习，工具已经可以强大到可以替代大部分重复劳动的工种。<br>　　但是问题就在这里，现在的工具还不够成熟。<br>　　你无法忽视网络协议，无法忽视性能，无法忽视安全。<br>　　如果有一天，工具能够解决这些问题了。我们应该感觉到开心，大可不必担心自己被替代。<br>因为，可以转行做产品经理啊。(｡･∀･)ﾉﾞ&quot;</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
